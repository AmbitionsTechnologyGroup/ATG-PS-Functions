Function Add-ChromeShortcut{
	#Requires -RunAsAdministrator

	param
	(
		[Parameter(Mandatory=$true)]
		[string]$Label,

		[Parameter(Mandatory=$true)]
		[string]$Url
	)

	If (Test-Path -Path 'C:\Program Files\Google\Chrome\Application\chrome.exe') {
		$TargetFile = "C:\Program Files\Google\Chrome\Application\chrome.exe"
	} ElseIf (Test-Path -Path 'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe') {
		$TargetFile = "C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"
	} Else {
		Write-Host "Google Chrome was not found. Please install manually or with Chocolatey:"
		Write-Host "   Install-Choco"
		Write-Host "   choco install GoogleChrome"
	}

	If ($TargetFile) {
		$ShortcutFile = "$env:Public\Desktop\" + $Label + ".lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Arguments = $Url
		$Shortcut.Save()
	}
	<#
	.SYNOPSIS
		Creates a Google Chrome Shortcut on the "All Users" Desktop.
		If Google Chrome is not found, prompts to install the program using ATG-PS scripts + Chocolately.
	.PARAMETER Label
		The file name of the shortcut; ".lnk" is automatically appended.
	.PARAMETER Url
		The full URL that the shortcut intends to open: "https://www.google.com/"
	.EXAMPLE
		Add-ChromeShortcut -Label "Github ATG-PS" -Url "https://github.com/AmbitionsTechnologyGroup/ATG-PS-Functions/"
	#>
}

Function Add-FileFolderShortcut {

	param
	(
		[Parameter(Mandatory=$true)]
		[string]$SourceLnk,

		[Parameter(Mandatory=$true)]
		[string]$DestinationPath
	)

	$WshShell = New-Object -comObject WScript.Shell
	$Shortcut = $WshShell.CreateShortcut($SourceLnk)
	$Shortcut.TargetPath = $DestinationPath
	$Shortcut.Save()

	<#
	.SYNOPSIS
		Creates a shortcut to a file or folder.
	.PARAMETER SourceLnk
		The file name of the shortcut. Must end with ".lnk"
	.PARAMETER DestinationPath
		What the shortcut is pointing to. "C:\Ambitions\RyanIsAwesome.txt"
	.EXAMPLE
		Add-FileFolderShortcut "$env:Public\Desktop\Ambitions Folder.lnk" "C:\Ambitions"
		This example puts a shortcut on the desktop called "Ambitions Folder" and points to C:\Ambitions.
	#>

}

Function Add-IEShortcut {
	param
	(
		[Parameter(Mandatory=$true)]
		[string]$Label,

		[Parameter(Mandatory=$true)]
		[string]$Url
	)

	$TargetFile = "C:\Program Files\Internet Explorer\iexplore.exe"
	$ShortcutFile = "$env:Public\Desktop\" + $Label + ".lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.Arguments = $Url
	$Shortcut.Save()

	<#
	.SYNOPSIS
		Creates an Internet Explorer Shortcut on the "All Users" Desktop.
	.PARAMETER Label
		The file name of the shortcut; ".lnk" is automatically appended.
	.PARAMETER Url
		The full URL that the shortcut intends to open: "https://www.google.com/"
	.EXAMPLE
		Add-ChromeShortcut -Label "Github ATG-PS" -Url "https://github.com/AmbitionsTechnologyGroup/ATG-PS-Functions/"
	#>

}

Function Add-WebShortcut{
	param
	(
		[string]$Label,
		[string]$Url
	)

	Write-Host "Adding a shortcut to $Label to the desktop"
	$Shell = New-Object -ComObject ("WScript.Shell")
	$URLFilePath = $env:Public + "\Desktop\" + $Label + ".url"
	$Favorite = $Shell.CreateShortcut($URLFilePath)
	$Favorite.TargetPath = $Url
	$Favorite.Save()
}

Function Backup-LastUser {
	$RegKey = "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI"
	$RegFile = "C:\Ambitions\LastLoggedOnUser.reg"
	Write-Host "Backuping up last logged on user"
	reg export $RegKey $RegFile /y
	Write-Host "Trimming export"
	(Get-Content $RegFile)[0..10] | Out-File -FilePath $RegFile -Force
	$User = (Select-String -Path $RegFile -Pattern '"LastLoggedOnUser"' -SimpleMatch).Line
	Write-Host "$User has been backed up to $RegFile"
	Write-Host "`nTry the command Restore-LastUser"
<#
	.SYNOPSIS
		Backup-LastUser affects the user listed on the Windows Logon screen. If Sally is the last one that logged in, and she's use to just turning on her computer and entering her password because she's always the last one that used the computer, it'll really mess her up if you log in to fix something. Then she'll be entering her password on the admin account without ever looking to see that she needs to switch user back to herself.
		Use the command "Backup-LastUser". This saves Sally as a registry key.
		You login, do your stuff, then reboot or log out.
		Use the command "Restore-LastUser". This will change the default user at the login screen from "ATGAdmin" back to "Sally" or whatever user was backed up.
	.EXAMPLE
		Backup-LastUser
			Backuping up last logged on user
			The operation completed successfully.
			Trimming export
			"LastLoggedOnUser"=".\\Sally" has been backed up to C:\Ambitions\LastLoggedOnUser.reg
			Try the command Restore-LastUser
#>
}

Function Connect-NetExtender {
	param
	(
		[Parameter(Mandatory=$False)]
		[string]$DC,

		[Parameter(Mandatory=$true)]
		[string]$VPNuri,

		[Parameter(Mandatory=$true)]
		[string]$VPNuser,

		[Parameter(Mandatory=$true)]
		[string]$VPNpassword,

		[Parameter(Mandatory=$true)]
		[string]$VPNdomain
	)

	If (([string]::IsNullOrWhiteSpace($DC)) -or (-not (Test-Connection -comp $DC -quiet))) {
		If (!(Test-Path -LiteralPath 'C:\Program Files (x86)\SonicWALL\SSL-VPN\NetExtender\NEClI.exe')) {
			Install-NetExtender
		}
		Write-host "Initiating VPN connection"
		echo y | & 'C:\Program Files (x86)\SonicWALL\SSL-VPN\NetExtender\NEClI.exe' connect -s $VPNuri -u $VPNuser -p $VPNpassword -d $VPNdomain
	}
<#
	.SYNOPSIS
		Initiates an SSLVPN connection to a site using Sonicwall NetExtender
	.PARAMETER DC
		(Optional) A domain controller whose connection to can be tested to see if the vpn connection is needed. Example -DC "tsdc"
	.PARAMETER VPNuri
		The connection URL and port. Example -VPNuri "vpn.ambitinsgroup.com:4433"
	.PARAMETER VPNuser
		The vpn enable user to be used. Example -VPNuser "vpnuser"
	.PARAMETER VPNpassword
		The vpn user's password to be used. Example -VPNpassword "s0m3Gr3@tPw"
	.PARAMETER VPNdomain
		The SSLVPN domain to be used, found in the sonicwall settings. Example -VPNdomain "LocalDomain"
	.EXAMPLE
		Connect-NetExtender -DC "TSDC" -VPNuri "vpn.ts.com:4433" -VPNuser "tsadmin" -VPNpassword "R@nD0m!" -VPNdomain "LocalDomain"
		This example connects to the client Test Site, if such a client were to exist.
#>
}

Function Connect-O365Exchange {
		If (-not (Get-Command Connect-ExchangeOnline -ErrorAction SilentlyContinue)) {
			Write-Host "Installing the Exchange Online Management module"
			Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
			Install-Module -Name ExchangeOnlineManagement -AllowClobber -Force
			$ModVer = (Get-Command Connect-ExchangeOnline).Version
			If ($ModVer) {
				Write-Host "Exchange Online Management module version $ModVer has been installed."
			} Else {
				Write-Host "Exchange Online Management module failed to install."
				Break
			}
		} Else {
			$Readhost = 'N'
			$Readhost = Read-Host "Do you want to check for module updates? This should be done periodically. `n(y/N)"
			Switch ($ReadHost)
			{
				Y {
					$ModVer = (Get-Command Connect-ExchangeOnline).Version
					$AvailableModVer = (Find-Module ExchangeOnlineManagement -Repository PSGallery).Version
					If ($ModVer -ne $AvailableModVer) {
						Write-host "ExchangeOnlineManagement has an update from $ModVer to $AvailableModVer.`nInstalling the update."
						Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
						Install-Module -Name ExchangeOnlineManagement -AllowClobber -Force
					} Else {
						Write-host "ExchangeOnlineManagement is already up to date at version $AvailableModVer."
					}
				}
				N { Write-Host "Skipping update check." }
				Default { Write-Host "Skipping update check." }
			}
		}

	If ($PSVersionTable.PSEdition -like "Desktop") {
		Connect-ExchangeOnline -ShowBanner:$false

	} Else {
		Write-Host -ForegroundColor Green -BackgroundColor DarkRed "Warning! You are using a CORE edition of Powershell. You will need to authenticate via a browser window."
		Connect-ExchangeOnline -ShowBanner:$false -Device
	}

	Write-Host -ForegroundColor White -BackgroundColor DarkRed @"
		Be sure to disconnect the remote PowerShell session when you're finished.
		If you close the Windows PowerShell window without disconnecting the session,
		you could use up all the remote PowerShell sessions available to you,
		and you'll need to wait for the sessions to expire.
		To disconnect the remote PowerShell session, run the following command.

		Disconnect-O365Exchange
"@

<#
	.SYNOPSIS
		Initiates an Office 365 Exchange connection that is compatible with MFA.
		This is not compatible with Powershell Core.

	.LINK
		https://docs.microsoft.com/en-us/powershell/exchange/connect-to-exchange-online-powershell?view=exchange-ps

	.EXAMPLE
		Connect-O365Exchange
		Yup, that's it!
#>
}

Function Connect-Wifi {
	param
		(
			[Parameter(Mandatory=$False)]
			[string]$NetworkSSID,

			[Parameter(Mandatory=$true)]
			[string]$NetworkPassword,

			[ValidateSet('WEP','WPA','WPA2','WPA2PSK')]
			[Parameter(Mandatory=$False)]
			[string]$Authentication = 'WPA2PSK',

			[ValidateSet('AES','TKIP')]
			[Parameter(Mandatory=$False)]
			[string]$Encryption = 'AES'
		)

	# Create the WiFi profile, set the profile to auto connect
	$WirelessProfile = @'
<WLANProfile xmlns="http://www.microsoft.com/networking/WLAN/profile/v1">
	<name>{0}</name>
	<SSIDConfig>
		<SSID>
			<name>{0}</name>
		</SSID>
	</SSIDConfig>
	<connectionType>ESS</connectionType>
	<connectionMode>auto</connectionMode>
	<MSM>
		<security>
			<authEncryption>
				<authentication>{2}</authentication>
				<encryption>{3}</encryption>
				<useOneX>false</useOneX>
			</authEncryption>
			<sharedKey>
				<keyType>passPhrase</keyType>
				<protected>false</protected>
				<keyMaterial>{1}</keyMaterial>
			</sharedKey>
		</security>
	</MSM>
</WLANProfile>
'@ -f $NetworkSSID, $NetworkPassword, $Authentication, $Encryption

	# Create the XML file locally
	$random = Get-Random -Minimum 1111 -Maximum 99999999
	$tempProfileXML = "$env:TEMP\tempProfile$random.xml"
	$WirelessProfile | Out-File $tempProfileXML

	# Add the WiFi profile and connect
	Start-Process netsh ('wlan add profile filename={0}' -f $tempProfileXML)

	# Connect to the WiFi network - only if you need to
	$WifiNetworks = (netsh wlan show network)
	$NetworkSSIDSearch = '*' + $NetworkSSID + '*'
	If ($WifiNetworks -like $NetworkSSIDSearch) {
		Try {
			Write-Host "Found SSID: $NetworkSSID `nAttempting to connect"
			Start-Process netsh ('wlan connect name="{0}"' -f $NetworkSSID)
			Start-Sleep 5
			netsh interface show interface
		}
		Catch {
			Remove-Item -Force $tempProfileXML
		}
	} Else {
		Write-Host "Did not find SSID: $NetworkSSID `nConnection profile stored for later use."
	}
	Remove-Item -Force $tempProfileXML
}

Function Debug-UmbrellaDNS {
	$X64exe = ${Env:ProgramFiles(x86)} + "\OpenDNS\Umbrella Roaming Client\UmbrellaDiagnostic.exe"
	$X86exe = $ENV:ProgramFiles + "\OpenDNS\Umbrella Roaming Client\UmbrellaDiagnostic.exe"
	If (Test-Path $X64exe -ea SilentlyContinue) {
		$UDexe = $X64exe
	} ElseIf (Test-Path $X86exe -ea SilentlyContinue) {
		$UDexe = $X86exe
	} Else {
		Write-Host "Umbrella Diagnostics do not appear to be installed."
		Break
	}
	Write-Host "Here is the help file for UmbrellaDiagnostic.exe:"
Write-Host @"

  -d, --domain=VALUE         A specific URL to target with tests (e.g.
                               opendns.com)
  -s, --silent               Automatically run tests in silent mode (will not
                               show the UI or new windows; defaults to -i
                               output)
  -i, --internet             Output all results to diagnostic.opendns.com;
                               destination URL will print to console as
                               'url=URL'
  -o, --output=VALUE         Output to a file, which will print to console as
                               'outputFile=FILE'; can be a full path, make sure
                               to use "quotes" if needed
  -c, --console              Output all results to console as text
      --erc                  Force the Roaming Client tests to be performed
      --noerc                Skip the Roaming Client tests even if it's
                               installed
  -h, -?, --help             Display this usage statement

If run without -o or -c arguments, -i is the default output; if run with -o or -c, then -i must be explicitly set if desired as additional output.

"@
	Write-Host "Recommend running with arguments '--silent --internet --console'.`nAdd --domain=<domain> to test internal or external targets.`n"
	$Args = Read-Host "What arguments would you like to add? Just press enter if you wish to launch the window.`n"
	If ($Args) {
		Start-Process $UDexe -ArgumentList $Args
	} Else {
		Start-Process $UDexe
	}
}

Function Disconnect-O365Exchange {
	Disconnect-ExchangeOnline -Confirm:$false
}

Function Disable-ATGLocalExpiration {
	Write-Host "Set local ATGLocal account to never expire"
		Set-LocalUser -Name "ATGLocal" -PasswordNeverExpires $True
}

Function Convert-ToSharedMailbox {
	param
		(
			[Parameter(Mandatory=$false)]
			[string]$DateLeft,

			[Parameter(Mandatory=$false)]
			[string]$Alias,
			
			[Parameter(Mandatory=$false)]
			[string]$GiveAccessTo,
			
			[Parameter(Mandatory=$false)]
			[ValidateSet('FullAccess','ReadPermission')]
			[string]$GiveAccessPermission,
			
			[Parameter(Mandatory=$false)]
			[string]$DirectEmailTo,
			
			[Parameter(Mandatory=$false)]
			[switch]$NoAccess = $False,
			
			[Parameter(Mandatory=$false)]
			[switch]$NoReply = $False
		)
		
	If (-not $DateLeft) {$DateLeft = Read-Host "Please enter the date this person left in DDMMMYYY format, i.e. 01JAN2001"}
	If (-not $Alias) {$Alias = Read-Host "Please enter the persons alias, the part of their email before the @ sign."}
	$DeletedMailbox = Get-EXOMailbox -SoftDeletedMailbox -Identity $Alias -ErrorAction SilentlyContinue
	If (-not $DeletedMailbox) {
		Do {
			#Active User Check
			If ($(Get-EXOMailbox -Identity $Alias -ErrorAction SilentlyContinue)) {
				Write-Host "That mailbox appears to be for an active user.`nPlease delete the user before proceeding..."
				Break
			}
			#Retry the alias
			$Alias = Read-Host "That alias didn't work. Enter another one or type QUIT to stop:`n"
			If ($Alias -match "QUIT") {Break}
			$DeletedMailbox = Get-EXOMailbox -SoftDeletedMailbox -Identity $Alias -ErrorAction SilentlyContinue
		} While (-not $DeletedMailbox)
	}
	
	If ($DeletedMailbox) {
		Write-Host "Deleted mailbox found."
		$Name = $DeletedMailbox.DisplayName
		$SmtpAddress = $DeletedMailbox.PrimarySmtpAddress
		Write-Host "Creating Shared Mailbox."
		New-Mailbox -Name "SHARED $Name LEFT $DateLeft" -Alias $Alias -PrimarySmtpAddress $SmtpAddress -Shared
		Write-Host "Waiting 30 seconds for mailbox to fully initialize."
		Sleep -Seconds 30
		$NewSharedMailbox = Get-EXOMailbox -Identity $Alias
		$NewSharedMailbox | Select DisplayName, RecipientTypeDetails
		Write-Host "Restoring deleted mailbox to new shared mailbox."
		New-MailboxRestoreRequest -SourceMailbox $DeletedMailbox.GUID.GUID -TargetMailbox $NewSharedMailbox.GUID.GUID -AllowLegacyDNMismatch
		Get-MailboxRestoreRequest | FT
		Write-Host -ForegroundColor Yellow -BackgroundColor Black "Run Get-MailboxRestoreRequest to see the progress of the restore."

		#Mailbox Permissions
		If(-not $NoAccess) {
			Do {
				If ($GiveAccessPermission) {
					$Permission = $GiveAccessPermission
				} Else {
					$Response = Read-Host -Prompt "Do you want to add any permissions to the shared mailbox? (Y/n)"
					If (-not $Response) {$Response = "y"}
					If ($Response -like 'y*') {
					$Rights = "FullAccess","ReadPermission","QUIT"
					$Rights | Select-Object @{N='Index'; E={$Rights.IndexOf($_)}}, @{N='Permission'; E={$_}} | Out-Host -Paging -ErrorAction SilentlyContinue
					$Permission = Read-Host "Please enter the number of the permission you wish to assign."
					$Permission = $Rights[$Permission]
					}
				}
				If ($Permission -ne "QUIT") {
					If ($GiveAccessTo) {
						$AddUser = $GiveAccessTo
					} Else {
						$AddUser = Read-Host "Alias of the user to grant access"
					}
					If (-not $(Get-EXOMailbox -Identity $AddUser)) {
						Do {
							$AddUser = Read-Host "That alias didn't work. Enter another one or type QUIT to stop:`n"
							If ($AddUser -match "QUIT") {Break}
						} While (-not $(Get-EXOMailbox -Identity $AddUser))
					}
					Write-Host "Giving $AddUser $Permission to the mailbox."
					$NewSharedMailbox | Add-MailboxPermission -User $AddUser -AccessRights $Permission -InheritanceType All -Verbose
					$NewSharedMailbox | Get-MailboxPermission | FT
				} Else { Break }
			} While ($Response -notlike 'n*')
		}

		#AutoReply
		If(-not $NoAccess) {
			If ($DirectEmailTo) {
				$ReplyTo = $DirectEmailTo
			} Else {
				$Response = Read-Host -Prompt "Do you want to an auto reply? (Y/n)"
				If (-not $Response) {$Response = "y"}
				If ($Response -like 'y*') {
					$ReplyTo = Read-Host "Alias of the user to direct emails to"
					If (-not $(Get-EXOMailbox -Identity $ReplyTo)) {
						Do {
							$ReplyTo = Read-Host "That alias didn't work. Enter another one or type QUIT to stop:`n"
							If ($ReplyTo -match "QUIT") {Break}
						} While (-not $(Get-EXOMailbox -Identity $ReplyTo))
					}

				}
			}
			$ReplyTo = Get-EXOMailbox -Identity $ReplyTo
			$ReplyToName = $ReplyTo.DisplayName
			$ReplyToEmail = $ReplyTo.PrimarySmtpAddress
			$NewSharedMailbox | Set-MailboxAutoReplyConfiguration –InternalMessage "$Name is no longer with the organization. Please direct communications to $ReplyToName at $ReplyToEmail" –ExternalMessage "$Name is no longer with the organization. Please direct communications to $ReplyToName at $ReplyToEmail" -Verbose
			$NewSharedMailbox | Set-MailboxAutoReplyConfiguration -AutoReplyState enabled
			$NewSharedMailbox | Get-MailboxAutoReplyConfiguration | Select Identity, AutoReplyState, ExternalMessage | FL
		}
	}
<#
	.SYNOPSIS
		Takes a deleted user, and converts their email to a shared mailbox. Can add permissions and an autoreply.
	.PARAMETER Alias
		Please enter the persons alias, the part of their email before the @ sign.
	.PARAMETER DateLeft
		Please enter the date this person left in DDMMMYYY format, i.e. 01JAN2001
	.PARAMETER GiveAccessTo
		Please enter the alias of the person who needs access to the shared mailbox. Leave blank to be prompted for multiple names.
	.PARAMETER GiveAccessPermission
		Please enter the permission level to give. Acceptible values are 'FullAccess' and 'ReadPermission'.
	.PARAMETER DirectEmailTo
		Please enter the alias of the person who people should be directed to in the auto reply.
	.PARAMETER NoAccess
		Add this switch if you do not want to be prompted for giving access.
	.PARAMETER NoReply
		Add this switch if you do not want to be prompted for setting up an autoreply.
	.EXAMPLE
		Convert-ToSharedMailbox -DateLeft "30SEP2021" -Alias cscippio
	#>
}

Function Disable-DailyReboot {
<#
	.SYNOPSIS
		Permanently deletes the scheduled task named "Daily Restart"
#>
	$DailyRebootTask = Get-ScheduledTask -TaskName "Daily Restart" -ErrorAction SilentlyContinue
	If ($DailyRebootTask) {
		$DailyRebootTask | Unregister-ScheduledTask -Confirm:$false
	}
	If (!(Get-ScheduledTask -TaskName "Daily Restart" -ErrorAction SilentlyContinue)) {
		Write-Host "The task 'Daily Restart' has been successfully removed."
	} Else {
		Write-Host "The task 'Daily Restart' has NOT been successfully removed. Please investigate!"
	}
}

Function Disable-FastStartup {
	Write-Host "Disable Windows Fast Startup"
		REG ADD "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Power" /v HiberbootEnabled /t REG_DWORD /d "0" /f
		powercfg -h off
}

Function Disable-Sleep {
<#
.Synopsis
   Function to suspend your current Power Plan settings when running a PowerShell script.
.SYNOPSIS
   Function to suspend your current Power Plan settings when running a PowerShell script.
   Scenario: When downloading files using Robocopy from PowerShell you don't want your
   laptop to go into sleep mode.
.EXAMPLE
   Disable-Sleep
   Run mylongrunningscript with Display idle timeout prevented and verbose messages
#>

	If (!(Test-Path "C:\ProgramData\chocolatey\lib\dontsleep.portable\tools\DontSleep_x64_p.exe")) {
		If (!(Get-Command choco -ErrorAction SilentlyContinue)) {Install-Choco}
		choco install dontsleep.portable -y
	}
	& C:\ProgramData\chocolatey\lib\dontsleep.portable\tools\DontSleep_x64_p.exe -bg please_sleep_mode=0 enable=1
}

Function Disconnect-AllUsers {
<#
	.SYNOPSIS
		Logs off all users from a machine.
#>
	(quser) -replace ">"," " -replace "\s+","," -replace "IDLE,TIME","IDLE TIME" -replace "LOGON,TIME","LOGON TIME" | ConvertFrom-Csv -Delimiter "," | foreach {
		logoff ($_.ID)
	}
}

Function Disconnect-NetExtender {

	If (([string]::IsNullOrWhiteSpace($DC)) -or (-not (Test-Connection -comp $DC -quiet))) {
		If (!(Test-Path -LiteralPath 'C:\Program Files (x86)\SonicWALL\SSL-VPN\NetExtender\NEClI.exe')) {
			Write-Host "This command only works if you have Sonicwall NetExtender installed."
		}
		Write-host "Initiating VPN disconnection"
		& 'C:\Program Files (x86)\SonicWALL\SSL-VPN\NetExtender\NEClI.exe' disconnect
		& 'C:\Program Files (x86)\SonicWALL\SSL-VPN\NetExtender\NEClI.exe' disconnect
	}
<#
	.SYNOPSIS
		Disconnects an existing SSLVPN connection to a site using Sonicwall NetExtender
	.EXAMPLE
		Disconnect-NetExtender
		This example disconnects from the VPN session.
#>
}

Function Enable-O365AuditLog {
<#
	.SYNOPSIS
		Sets auditig on all mailboxes in the organization as well as sets the default setting.

	.LINK
		https://docs.microsoft.com/en-us/microsoft-365/compliance/enable-mailbox-auditing

	.LINK
		https://support.microsoft.com/en-us/help/4026501/office-auditing-in-office-365-for-admins
#>
	If (Get-Command Get-Mailbox -ErrorAction SilentlyContinue){
		Write-Host "Enabling Auditing for all existing mailboxes"
		Get-Mailbox -ResultSize Unlimited -Filter {RecipientTypeDetails -eq "UserMailbox"} | Set-Mailbox -AuditEnabled $true -Verbose
		Write-Host "Enabling Auditing for the organization as a whole"
		Set-OrganizationConfig -AuditDisabled $False
		Write-Host "Checking the orginazation config. If auditing is enabled, this setting should show as 'False'"
		Get-OrganizationConfig | Format-List AuditDisabled
	} Else {
		Write-Host "You are not connected to an exchange server. Try the command 'Connect-O365Exchange'"
	}
}

Function Enable-Sleep {
	If (Get-Process -Name "DontSleep_x64_p") {
		Write-Host "Resuming power management plan"
		Stop-Process -Name "DontSleep_x64_p" -Force
	} Else {
		Write-Host "Disable-Sleep wasn't running. Did you run 'Disable-Sleep'?"
	}
}

Function Enable-SSL {
	Write-Host "Enabling SSL"
	try {
	# Set TLS 1.2 (3072), then TLS 1.1 (768), then TLS 1.0 (192)
	# Use integers because the enumeration values for TLS 1.2 and TLS 1.1 won't
	# exist in .NET 4.0, even though they are addressable if .NET 4.5+ is
	# installed (.NET 4.5 is an in-place upgrade).
	[System.Net.ServicePointManager]::SecurityProtocol = 3072 -bor 768 -bor 192
	} catch {
	Write-Output 'Unable to set PowerShell to use TLS 1.2 and TLS 1.1 due to old .NET Framework installed. If you see underlying connection closed or trust errors, you may need to upgrade to .NET Framework 4.5+ and PowerShell v3+.'
	}
}

Function Expand-Terminal {
	mode con: cols=120 lines=60
	$host.UI.RawUI.BufferSize = New-Object System.Management.Automation.Host.Size(120,10240)
}

Function Export-LDAPSCertificate {
	<#
	.SYNOPSIS
		If the server responds to requests on the LDAPS port 636, the function will attempt to isolate the Certificate in use and export it to C:\Ambitions\LDAPScerExport.cer
	#>
	If (Test-NetConnection -ComputerName localhost -Port 636 -InformationLevel Quiet) {
		$Cert = (Get-ChildItem -Path Cert:\LocalMachine -Recurse | Where-Object {$_.NotAfter -Gt (Get-Date) -and $_.Subject -like "*$env:computername.$env:userdnsdomain*" -and $_.NotAfter -eq ($_.NotBefore).AddYears(1)})
		$Cert | Select-Object Subject, NotBefore, NotAfter | Format-List
		$Path = "C:\Ambitions\LDAPScerExport.cer"
		Write-Host "Exporting current likely LDAPS Certificate to $Path"
		$Cert | Export-Certificate -Type cer -FilePath C:\Ambitions\LDAPScerExport.cer -Force | Out-Null
	} Else {
		Write-Warning "This computer does not appear to be serving LDAPS requests."
		Break
	}
}

Function Get-ADUserPassExpirations {
	<#
	.SYNOPSIS
		Retrieves a list of (enabled) Active Directory Users and shows their password expiration times.
	#>

	# check the name of the parent process.  If it's LogMeIn, we can't use the Out-GridView UI
	$parentProcessName = (Get-Process -Id ((Get-WmiObject Win32_Process -Filter "processid='$PID'").ParentProcessId)).Name

	# check to see whether Get-AdUser is available
	if (Get-Command ActiveDirectory\Get-AdUser -ErrorAction SilentlyContinue) {

		$adUserInfo = Get-ADUser -Filter {Enabled -eq $True -and PasswordNeverExpires -eq $False} `
		–Properties "DisplayName", "userPrincipalName", "msDS-UserPasswordExpiryTimeComputed" | `
		Select-Object -Property "Displayname","userPrincipalName",@{Name="ExpiryDate";Expression={[datetime]::FromFileTime($_."msDS-UserPasswordExpiryTimeComputed")}}

		# if the parent process of this powershell instance is not explorer.exe, output to PowerShell table.
		If ($parentProcessName -ne "explorer") {
			$adUserInfo | Format-Table -AutoSize
		} else { # otherwise, grid view UI
			$adUserInfo | Out-GridView -Title "ATG Powershell --> User Password Expirations"
		}

	} else { # cannot continue, Get-AdUser is not available
		Write-Host "`n [!] This command must be run on a system with Active Directory Powershell Modules (i.e. a domain controller)`n"
	}
}

Function Get-ATGPS {
	If (Get-Module -Name ATGPS -ErrorAction SilentlyContinue){
		# List imported functions from ATGPS
		Write-Host ====================================================
		Write-Host "The below functions are now loaded and ready to use:"
		Write-Host ====================================================
			Get-Command -Module ATGPS | Format-Wide -Column 3
		Write-Host ====================================================
		Write-Host "Type: 'Help <function name> -Detailed' for more info"
		Write-Host ====================================================
	} Else {
	$progressPreference = 'silentlyContinue'
	iex(iwr ps.acgs.io -UseBasicParsing)
	# List imported functions from ATGPS
		Write-Host ====================================================
		Write-Host "The below functions are now loaded and ready to use:"
		Write-Host ====================================================
			Get-Command -Module ATGPS | Format-Wide -Column 3
		Write-Host ====================================================
		Write-Host "Type: 'Help <function name> -Detailed' for more info"
		Write-Host ====================================================
	}
}

Function Get-BitLockerKey {
	param
		(
			[Parameter(Mandatory=$false)]
			[string]$Computer
		)
	#$Computer = "OPTIPLEX7040-20"
	$Computers = Get-ADComputer -Filter 'ObjectClass -eq "computer"'
	$AllComputers = @()
	#$strToReport = new-object psobject
	$Computers | Foreach-object {
		#$Computer = $_.name
		#Check if the Computer Object exists
		$Computer_Object = Get-ADComputer -Filter {cn -eq $_.name} -Property msTPM-OwnerInformation, msTPM-TpmInformationForComputer
		If ($Computer_Object -eq $null){
			Write-Host "Error..."
		}
		#Check if the computer object has had a BitLocker Recovery Password
		$Bitlocker_Object = Get-ADObject -Filter {objectclass -eq 'msFVE-RecoveryInformation'} -SearchBase $Computer_Object.DistinguishedName -Properties 'msFVE-RecoveryPassword' | Select-Object -Last 1
		If ($Bitlocker_Object.'msFVE-RecoveryPassword'){
			$BitLocker_Key = $BitLocker_Object.'msFVE-RecoveryPassword'

			#$strToReport = $_.name,$BitLocker_Key
			$strToReport = [PSCustomObject]@{
				Computer = $_.name
				BitLockerKey = $BitLocker_Key
			}
			$AllComputers += $strToReport
			#Display Output
			#Write-Host $strToReport

			#Save to Report
			#$strToReport | Out-File C:\temp\Report.txt -append
		} Else {
			$BitLocker_Key = "None"
			#$strToReport = $_.name,$BitLocker_Key
			$strToReport = [PSCustomObject]@{
				Computer = $_.name
				BitLockerKey = $BitLocker_Key
			}
			$AllComputers += $strToReport
			#Write-Host $strToReport
		}
	}
	If ($Computer) {
		If ($AllComputers.Computer -NotContains $Computer) {
			Write-Host "The computer specified was not found."
		} Else {
			$ComputerInfo = new-object psobject
			$ComputerInfo = $AllComputers | Where-Object -Property Computer -eq -Value $Computer
			$ComputerInfo | Format-List
			If ($ComputerInfo.BitlockerKey -eq "None") {
				Write-Host "There is no bitlocker key for this compuer."
			} Else {

				Write-Host "The bitlocker key has been copied to the clipboard.`n"
				$ComputerInfo.BitlockerKey | Clip
			}
		}
	} Else {
		$AllComputers
	}

<#
	.SYNOPSIS
		Takes a deleted user, and converts their email to a shared mailbox. Can add permissions and an autoreply.
	.PARAMETER Computer
		[Optional] Specify the name of the computer to retrieve the BitLockerKey for. Will copy the key to the clipboard if specified.
	.EXAMPLE
		Get-BitLockerKey -Computer "ACG-Desktop23"
	#>
}

Function Get-DiskUsage($path=".") {
    Write-Host -ForegroundColor Cyan "  (large folders may take long to calculate...)"
    Get-ChildItem $path | ForEach-Object {
        $file = $_
        Get-ChildItem -r $_.FullName |
        Measure-Object -property length -sum -ErrorAction SilentlyContinue |
        Select-Object @{Name="Name";Expression={$file}},
        @{Name="Space Used (MB)";Expression={([math]::Round(($_.Sum/1024/1024),2))}}
    } | Format-Table -AutoSize
	<#
	.SYNOPSIS
		Either in the current directory or the given path, find all child items
		and calculate their cumulative size. Output the name of the folder
		and the space used in Megabytes. If this function is loaded by normal
		means for this repository, it will be available by its assigned alias 'du'.
	.PARAMETER Path
		[Optional] Path to the folder to calculate size of child items.
	.EXAMPLE
		Get-DiskUsage "C:\Users"
	.EXAMPLE
		Get-DiskUsage $env:OneDrive\Documents
	#>
}
Set-Alias -Name du -Value Get-DiskUsage

Function Get-ThunderBolt {
	$Thunderbolt = Get-WmiObject Win32_SystemDriver | Where-Object -Property DisplayName -Like "*Thunder*"
	If ($Thunderbolt) {
		Write-Host "The following ThunderBolt controllers have been detected:"
		$Thunderbolt
	} Else {
		Write-Host "No Thunderbolt Controllers have been detected"
	}
}

Function Get-InternetHealth {
	######### Absolute monitoring values ##########
	$maxpacketloss = 2 #how much % packetloss until we alert.
	$MinimumDownloadSpeed = 100 #What is the minimum expected download speed in Mbit/ps
	$MinimumUploadSpeed = 20 #What is the minimum expected upload speed in Mbit/ps
	$MaxJitter = 30
	######### End absolute monitoring values ######

	#Replace the Download URL to where you've uploaded the ZIP file yourself. We will only download this file once.
	#Latest version can be found at: https://www.speedtest.net/nl/apps/cli
	$DownloadURL = "https://install.speedtest.net/app/cli/ookla-speedtest-1.0.0-win64.zip"
	$DownloadLocation = "$($Env:ProgramData)\SpeedtestCLI"
	$SpeedTestExe = Join-Path -Path $DownloadLocation -ChildPath "\speedtest.exe"
	Try {
		If (!$(Test-Path $SpeedTestExe)) {
			Write-Host "Preparing Internet Health Test."
			New-Item $DownloadLocation -ItemType Directory -force
			Invoke-WebRequest -Uri $DownloadURL -OutFile "$($DownloadLocation)\speedtest.zip"
			Expand-Archive "$($DownloadLocation)\speedtest.zip" -DestinationPath $DownloadLocation -Force
		}
	} Catch {
		Write-Host "The download and extraction of SpeedtestCLI failed. Error: $($_.Exception.Message)"
		#exit 1
		Return
	}
	$PreviousResults = If (test-path "$($DownloadLocation)\LastResults.txt") { get-content "$($DownloadLocation)\LastResults.txt" | ConvertFrom-Json }
	Write-Host "Running Internet Health Test."
	$SpeedtestResults = & $SpeedTestExe --format=json --accept-license --accept-gdpr
	$SpeedtestResults | Out-File "$($DownloadLocation)\LastResults.txt" -Force
	$SpeedtestResults = $SpeedtestResults | ConvertFrom-Json

	#creating object
	[PSCustomObject]$SpeedtestObj = @{
		downloadspeed = [math]::Round($SpeedtestResults.download.bandwidth / 1000000 * 8, 2)
		uploadspeed   = [math]::Round($SpeedtestResults.upload.bandwidth / 1000000 * 8, 2)
		packetloss    = [math]::Round($SpeedtestResults.packetLoss)
		isp           = $SpeedtestResults.isp
		ExternalIP    = $SpeedtestResults.interface.externalIp
		InternalIP    = $SpeedtestResults.interface.internalIp
		UsedServer    = $SpeedtestResults.server.host
		ResultsURL    = $SpeedtestResults.result.url
		Jitter        = [math]::Round($SpeedtestResults.ping.jitter)
		Latency       = [math]::Round($SpeedtestResults.ping.latency)
	}
	$SpeedtestHealth = @()
	#Comparing against previous result. Alerting is download or upload differs more than 20%.
	If ($PreviousResults) {
		Write-Host "Comparing against previous results."
		If ($PreviousResults.download.bandwidth / $SpeedtestResults.download.bandwidth * 100 -le 80) { $SpeedtestHealth += "Download speed difference is more than 20%" } Else { $SpeedtestHealth += "Download speed appears stable" }
		If ($PreviousResults.upload.bandwidth / $SpeedtestResults.upload.bandwidth * 100 -le 80) { $SpeedtestHealth += "Upload speed difference is more than 20%" } Else { $SpeedtestHealth += "Upload speed appears stable" }
	}

	#Comparing against preset variables.
	Write-Host "Analyzing Results"
	If ($SpeedtestObj.downloadspeed -lt $MinimumDownloadSpeed) { $SpeedtestHealth += "Download speed is lower than $MinimumDownloadSpeed Mbit/ps" ; $HealthIssue = $True } Else { $SpeedtestHealth += "Download speed is acceptable" }
	If ($SpeedtestObj.uploadspeed -lt $MinimumUploadSpeed) { $SpeedtestHealth += "Upload speed is lower than $MinimumUploadSpeed Mbit/ps"  ; $HealthIssue = $True }Else { $SpeedtestHealth += "Upload speed is acceptable" }
	If ($SpeedtestObj.packetloss -gt $MaxPacketLoss) { $SpeedtestHealth += "Packetloss is higher than $maxpacketloss%"  ; $HealthIssue = $True } Else { $SpeedtestHealth += "Packet Loss is acceptable" }
	If ($SpeedtestObj.Jitter -gt $MaxJitter) { $SpeedtestHealth += "Jitter is higher than $MaxJitter%"  ; $HealthIssue = $True } Else { $SpeedtestHealth += "Jitter is acceptable" }

	Write-Host "Internet Health Test Results:"
	$SpeedtestObj | Format-Table -AutoSize -HideTableHeaders
	Write-Host "Internet Health Summary:"
	If ($HealthIssue) {Write-Host -ForegroundColor Yellow -BackgroundColor Black "There appears to be issues!" } Else { Write-Host -ForegroundColor Green -BackgroundColor Black "All tests results are optimal!"}
	$SpeedtestHealth
}

Function Get-LoginHistory {
	<#

	.SYNOPSIS
		This script reads the event log "Microsoft-Windows-TerminalServices-LocalSessionManager/Operational" from
		multiple servers and outputs the human-readable results to a CSV/Table. This data is not filterable in the
		native Windows Event Viewer.

		Version: November 9, 2016


	.SYNOPSIS
		This script reads the event log "Microsoft-Windows-TerminalServices-LocalSessionManager/Operational" from
		multiple servers and outputs the human-readable results to a CSV/Table.  This data is not filterable in
		the native Windows Event Viewer.

		NOTE: Despite this log's name, it includes both RDP logins as well as regular console logins1.

		Author:
		Mike Crowley
		https://BaselineTechnologies.com

	 .EXAMPLE

		Get-LoginHistory -ServersToQuery Server1, Server2 -StartTime "November 1"

	.LINK
		https://MikeCrowley.us/tag/powershell

	#>

	Param(
		[array]$ServersToQuery = (hostname),
		[datetime]$StartTime = "January 1, 1970"
	)

		foreach ($Server in $ServersToQuery) {

			$LogFilter = @{
				LogName = 'Microsoft-Windows-TerminalServices-LocalSessionManager/Operational'
				ID = 21, 23, 24, 25
				StartTime = $StartTime
				}

			$AllEntries = Get-WinEvent -FilterHashtable $LogFilter -ComputerName $Server

			$AllEntries | ForEach-Object {
				$entry = [xml]$_.ToXml()
				[array]$Output += New-Object PSObject -Property @{
					TimeCreated = $_.TimeCreated
					User = $entry.Event.UserData.EventXML.User
					IPAddress = $entry.Event.UserData.EventXML.Address
					EventID = $entry.Event.System.EventID
					ServerName = $Server
					}
				}
			}

		$FilteredOutput += $Output | Select-Object TimeCreated, User, ServerName, IPAddress, @{Name='Action';Expression={
					if ($_.EventID -eq '21'){"Logon"}
					if ($_.EventID -eq '22'){"Shell Start"}
					if ($_.EventID -eq '23'){"Logoff"}
					if ($_.EventID -eq '24'){"Disconnected"}
					if ($_.EventID -eq '25'){"Reconnection"}
					}
				}

		$FilteredOutput | Sort-Object -Property TimeCreated | Format-Table -AutoSize

	}

Function Install-AppDefaults {
	Write-Host "Downloading App Defaults"
	New-Item -ItemType Directory -Force -Path C:\Ambitions\ITS247Agent
	(New-Object System.Net.WebClient).DownloadFile('https://download.ambitionsgroup.com/AppDefaults.xml', 'C:\Ambitions\AppDefaults.xml')
	Write-Host "Deploying App Defaults"
	Dism.exe /online /import-defaultappassociations:'C:\Ambitions\AppDefaults.xml'
}

Function Install-Choco {
	Write-Host "Installing Chocolatey"
	$progressPreference = 'silentlyContinue'
	Set-ExecutionPolicy Bypass -Scope Process -Force
	Enable-SSL
	Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Chocolatey/installchoco.txt -UseBasicParsing | Invoke-Expression
}

Function Install-ITS247Agent {
	If ($SiteCode -and !$IAmJOB) {
		Start-Job -Name "InstallAgent" -InitializationScript {
			Write-Host "I'm running as a job!"
			$progressPreference = 'silentlyContinue'
			iex(iwr ps.acgs.io -UseBasicParsing)
		} -ScriptBlock {
			$global:SiteCode = $using:SiteCode
			$global:IAmJOB = $True
			Install-ITS247Agent
		} | Receive-Job -Wait #-AutoRemoveJob
	} ElseIf (($SiteCode -and $IAmJOB) -or (!$SiteCode -and !$IAmJOB)) {
		$progressPreference = 'silentlyContinue'
		Set-ExecutionPolicy Bypass -Scope Process -Force
		Enable-SSL
		Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/ITS247Agent/Install_ITS247_Agent_MSI.txt -UseBasicParsing | Invoke-Expression
	} ElseIf (!$SiteCode -and $IAmJOB) {Write-Warning "You can't run the installer as job without specifying the SiteCode Variable. You can't interact with a job."}

}

Function Install-NetExtender {
	$App = Get-WmiObject -Class Win32_Product | Where-Object -Property "Name" -Like "*NetExtender*"

	If ($App) {
		$Name = $App.Name
		Write-Host "Uninstalling existing version of $Name"
		($App).Uninstall()
	}
	Write-Host "Downloading & Installing NetExtender"
		If (!(Get-Command choco -ErrorAction SilentlyContinue)) {Install-Choco}
		choco install sonicwall-sslvpn-netextender -y
}

Function Install-NiniteApps {
	If (-not (Test-Path 'C:\Ambitions\NinitePro.exe')) {Install-NinitePro}
	Write-Host "Install Ninite Apps, waiting for install to complete and logging the results."
		$NiniteCache = "\\adsaltoxl\data\Software\Ninite\NiniteDownloads"
		If(test-path $NiniteCache){
			& C:\Ambitions\NinitePro.exe /select 7-Zip Air Chrome 'Firefox ESR' Zoom Greenshot 'Notepad++' 'Paint.NET' Reader VLC /cachepath $NiniteCache /allusers /silent 'C:\Ambitions\NiniteReport.txt' | Wait-Process
		} ELSE {
			& C:\Ambitions\NinitePro.exe /select 7-Zip Air Chrome 'Firefox ESR' Zoom Greenshot 'Notepad++' 'Paint.NET' Reader VLC /nocache /allusers /silent 'C:\Ambitions\NiniteReport.txt' | Wait-Process
		}
	Get-Content 'C:\Ambitions\NiniteReport.txt'
	Write-Host "End of Install Ninite Apps"
}

Function Install-NinitePro {
	Write-Host "Downloading Ninite Installer"
	New-Item -ItemType Directory -Force -Path C:\Ambitions
	(New-Object System.Net.WebClient).DownloadFile('https://download.ambitionsgroup.com/Software/NinitePro.exe', 'C:\Ambitions\NinitePro.exe')
	Write-Host "Schedule Ninite Updates"
	$Trigger = New-ScheduledTaskTrigger -AtStartup
	$User = "NT AUTHORITY\SYSTEM"
	$Action = New-ScheduledTaskAction -Execute "C:\Ambitions\NinitePro.exe" -Argument "/updateonly /nocache /silent C:\Ambitions\NiniteUpdates.log"
	Register-ScheduledTask -TaskName "Update Apps" -Trigger $Trigger -User $User -Action $Action -RunLevel Highest -Force
	Write-Host "End of Schedule Ninite Updates"
}

Function Install-O2016STD([String] $MSPURL){
	Write-Host "Downloading MS Office"
		Enable-SSL
		New-Item -ItemType Directory -Force -Path 'C:\Ambitions\O2016STD'
		(New-Object System.Net.WebClient).DownloadFile('http://download.ambitionsgroup.com/Software/O2016_STD_X64.exe', 'C:\Ambitions\O2016STD\O2016_STD_X64.exe')

	Write-Host "Downloading MS Office config files"
		$MSPfilename = $MSPURL.Substring($MSPURL.LastIndexOf("/") + 1)
		$MSPfilepath = 'C:\Ambitions\O2016STD\' + $MSPfilename
		(New-Object System.Net.WebClient).DownloadFile($MSPURL, $MSPfilepath)

	Write-Host "Installing Office"
		& 'C:\Ambitions\O2016STD\O2016_STD_X64.exe' -pth!nSong70 -oC:\Ambitions\O2016STD -y | Wait-Process
		& 'C:\Ambitions\O2016STD\setup.exe' /adminfile $MSPfilepath | Wait-Process

	Write-Host "Placing Shortcuts"
		$TargetFile = 'C:\Program Files\Microsoft Office\Office16\OUTLOOK.EXE'
		$ShortcutFile = "$env:Public\Desktop\Outlook.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		$TargetFile = 'C:\Program Files\Microsoft Office\Office16\EXCEL.EXE'
		$ShortcutFile = "$env:Public\Desktop\Excel.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		$TargetFile = 'C:\Program Files\Microsoft Office\Office16\WINWORD.EXE'
		$ShortcutFile = "$env:Public\Desktop\Word.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()
}

Function Install-O365([String] $SiteCode = "Generic"){
	Write-Host "Downloading MS Office"
		Enable-SSL
		New-Item -ItemType Directory -Force -Path "C:\Ambitions\O365"
		(New-Object System.Net.WebClient).DownloadFile('https://download.ambitionsgroup.com/O365/setup.exe', 'C:\Ambitions\O365\setup.exe')
	Write-Host "Downloading MS Office config files"
		$O365ConfigSource = "https://download.ambitionsgroup.com/Sites/" + $SiteCode + "/" + $SiteCode + "_O365_Config.xml"
		$O365ConfigDest = "C:\Ambitions\O365\" + $SiteCode + "_O365_Config.xml"
		(New-Object System.Net.WebClient).DownloadFile($O365ConfigSource, $O365ConfigDest)
	Write-Host "Installing Office"
		& C:\Ambitions\O365\setup.exe /configure $O365ConfigDest | Wait-Process
	Write-Host "Placing Shortcuts"
		If (Test-Path "C:\Program Files\Microsoft Office\root\Office16\OUTLOOK.EXE"){
			$TargetFile = "C:\Program Files\Microsoft Office\root\Office16\OUTLOOK.EXE"
		} ELSEIF (Test-Path "C:\Program Files (x86)\Microsoft Office\root\Office16\OUTLOOK.EXE"){
			$TargetFile = "C:\Program Files (x86)\Microsoft Office\root\Office16\OUTLOOK.EXE"
		}
		$ShortcutFile = "$env:Public\Desktop\Outlook.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		If (Test-Path "C:\Program Files\Microsoft Office\root\Office16\EXCEL.EXE"){
			$TargetFile = "C:\Program Files\Microsoft Office\root\Office16\EXCEL.EXE"
		} ELSEIF (Test-Path "C:\Program Files (x86)\Microsoft Office\root\Office16\EXCEL.EXE"){
			$TargetFile = "C:\Program Files (x86)\Microsoft Office\root\Office16\EXCEL.EXE"
		}
		$ShortcutFile = "$env:Public\Desktop\Excel.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		If (Test-Path "C:\Program Files\Microsoft Office\root\Office16\WINWORD.EXE"){
			$TargetFile = "C:\Program Files\Microsoft Office\root\Office16\WINWORD.EXE"
		} ELSEIF (Test-Path "C:\Program Files (x86)\Microsoft Office\root\Office16\WINWORD.EXE"){
			$TargetFile = "C:\Program Files (x86)\Microsoft Office\root\Office16\WINWORD.EXE"
		}
		$ShortcutFile = "$env:Public\Desktop\Word.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()
}

Function Install-O365ProofPointConnectors {
<#
	.SYNOPSIS
		Installs the proofpoint inbound and outbound connectors in exchange online, as well as spam bypass for emails coming from exchange.
#>
	If (Get-Command Get-Mailbox -ErrorAction SilentlyContinue){
		Function Install-ProofPointInbound {
			New-InboundConnector -Name “Inbound from ProofPoint” -Comment “Only accept email from ProofPoint transport addresses” -Enabled $True  -SenderDomains * -RestrictDomainsToIPAddresses $true -RequireTls $true -SenderIPAddresses 148.163.159.0/24, 148.163.158.0/24, 148.163.157.0/24, 148.163.156.0/24, 148.163.155.0/24, 148.163.154.0/24, 148.163.153.0/24, 148.163.151.0/24, 148.163.150.0/24, 148.163.149.0/24, 148.163.148.0/24, 148.163.147.0/24, 148.163.146.0/24, 148.163.145.0/24, 148.163.143.0/24, 148.163.142.0/24, 148.163.141.0/24, 148.163.140.0/24, 148.163.139.0/24, 148.163.138.0/24, 148.163.137.0/24, 148.163.135.0/24, 148.163.134.0/24, 148.163.133.0/24, 148.163.132.0/24, 148.163.131.0/24, 148.163.130.0/24, 148.163.129.0/24, 52.54.85.198, 52.55.243.18, 34.192.199.2, 67.231.156.0/24, 67.231.155.0/24, 67.231.154.0/24, 67.231.153.0/24, 67.231.152.0/24, 67.231.148.0/24, 67.231.147.0/24, 67.231.146.0/24, 67.231.145.0/24, 67.231.144.0/24, 148.163.152.0/24, 148.163.144.0/24, 148.163.136.0/24, 148.163.128.0/24, 67.231.149.0/24
		}

		Function Install-ProofPointOutbound {
			New-OutboundConnector -Name “Outbound to ProofPoint” -Comment “Send all external outbound email through ProofPoint SmartHost” -Enabled $true -RecipientDomains * -SmartHosts outbound-us1.ppe-hosted.com -TlsSettings EncryptionOnly -UseMXRecord $false
		}

		If (Get-InboundConnector) {
			$Readhost = Read-Host "Warning, an inbound connector already exists.`nAre you sure you want to install the ProofPoint connector which may conflict?`n( y / n ) "
			Switch ($ReadHost)
			{
				Y { Write-Host "Installing the Proofpoint Inbound Connector.";Install-ProofPointInbound }
				N { break }
				Default { "You didn't enter the a correct response" }
			}
		} else {
			Write-Host "Installing the Proofpoint Inbound Connector."
			Install-ProofPointInbound
		}

		If (Get-OutboundConnector) {
			$Readhost = Read-Host "Warning, an outbound connector already exists.`nAre you sure you want to install the ProofPoint connector which may conflict? ( y / n ) "
			Switch ($ReadHost)
			{
				Y { Write-Host "Installing the Proofpoint Outbound Connector.";Install-ProofPointOutbound }
				N { break }
				Default { "You didn't enter the a correct response" }
			}
		} Else {
			Write-Host "Installing the Proofpoint Outbound Connector."
			Install-ProofPointOutbound
		}

		Set-HostedConnectionFilterPolicy “Default” -IPAllowList 148.163.147.0/24, 148.163.146.0/24, 148.163.145.0/24, 148.163.143.0/24, 148.163.142.0/24, 148.163.141.0/24, 148.163.140.0/24, 148.163.139.0/24, 148.163.138.0/24, 148.163.137.0/24, 148.163.135.0/24, 148.163.134.0/24, 148.163.133.0/24, 148.163.132.0/24, 148.163.131.0/24, 148.163.130.0/24, 148.163.129.0/24, 52.54.85.198, 52.55.243.18, 34.192.199.2, 67.231.156.0/24, 67.231.155.0/24, 67.231.154.0/24, 67.231.153.0/24, 67.231.152.0/24, 67.231.148.0/24, 67.231.147.0/24, 67.231.146.0/24, 67.231.145.0/24, 67.231.144.0/24, 148.163.152.0/24, 148.163.144.0/24, 148.163.136.0/24, 148.163.128.0/24, 67.231.149.0/24 -EnableSafeList $True
		Set-HostedContentFilterPolicy -Identity "Default" -AddXHeaderValue "Office 365 Notice: Possible Spam" -AdminDisplayName "Disabled 365 Filtering, inbound handled by Proofpoint." -BulkSpamAction "NoAction" -BulkThreshold 9 -DownloadLink $False -EnableEndUserSpamNotifications $False -EnableLanguageBlockList $False -EnableRegionBlockList $False -HighConfidencePhishAction MoveToJmf -HighConfidenceSpamAction AddXHeader -IncreaseScoreWithBizOrInfoUrls Off -IncreaseScoreWithImageLinks Off -IncreaseScoreWithNumericIps Off -IncreaseScoreWithRedirectToOtherPort Off -InlineSafetyTipsEnabled $False -MakeDefault -MarkAsSpamBulkMail Off -MarkAsSpamEmbedTagsInHtml Off -MarkAsSpamEmptyMessages Off -MarkAsSpamFormTagsInHtml Off -MarkAsSpamFramesInHtml Off -MarkAsSpamFromAddressAuthFail Off -MarkAsSpamJavaScriptInHtml Off -MarkAsSpamNdrBackscatter Off -MarkAsSpamObjectTagsInHtml Off -MarkAsSpamSensitiveWordList Off -MarkAsSpamSpfRecordHardFail Off -MarkAsSpamWebBugsInHtml Off -PhishSpamAction AddXHeader -PhishZapEnabled $False -QuarantineRetentionPeriod 30 -RedirectToRecipients $Null -RegionBlockList $Null -SpamAction AddXHeader -SpamZapEnabled $False -TestModeAction None -TestModeBccToRecipients $Null
		$DisableMailoxJunkFilters = Get-ExoMailbox -RecipientTypeDetails UserMailbox -ResultSize Unlimited; $All | foreach {Set-MailboxJunkEmailConfiguration $_.Name -Enabled $false}
	} Else {
		Write-Host "You are not connected to an exchange server. Try the command 'Connect-O365Exchange'."
	}
}

Function Install-UmbrellaDNS {
	#Requires -RunAsAdministrator
[cmdletbinding()]
param(
	[string]$Code #Shortcode of the site you want to install, list available at https://github.com/AmbitionsTechnologyGroup/ATG-PS-Functions/blob/master/Scripts/ITS247Agent/SiteAgentURLs.csv
)

	Write-Host "Checking Status Indicator"
	$IndicKey = Get-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\NetworkConnectivityStatusIndicator | Select-Object -ExpandProperty UseGlobalDNS -ea SilentlyContinue
	If ($IndicKey -ne 1) {
		Write-Host "Setting Connectivity Indicator Reg Key"
		New-Item "HKLM:\SOFTWARE\Policies\Microsoft\Windows\NetworkConnectivityStatusIndicator" -force -ea SilentlyContinue
		New-ItemProperty -LiteralPath 'HKLM:\SOFTWARE\Policies\Microsoft\Windows\NetworkConnectivityStatusIndicator' -Name 'UseGlobalDNS' -Value 1 -PropertyType DWord -Force -ea SilentlyContinue;
	} Else {
		Write-Host -ForegroundColor Green "The Status Indicator is already set."
	}

	Write-Host "Checking Root Certificate"
	$RootCertPath = "Cert:\LocalMachine\Root\C5091132E9ADF8AD3E33932AE60A5C8FA939E824" #Thumbprint of the Cert set to expire in 2036
	If (!(Test-Path $RootCertPath -ea SilentlyContinue)) {
		Write-Host "Downloading the Umbrella Root Cert"
		$url = 'https://download.ambitionsgroup.com/Software/Cisco_Umbrella_Root_CA.cer'
		$certFolder = $ENV:SystemDrive + '\Ambitions\UmbrellaClient\'
		$certFilePath = $certFolder + 'Cisco_Umbrella_Root_CA.cer'
		Remove-Item $certFilePath -ea SilentlyContinue
		$null = (New-Item -ItemType Directory -Force -Path $certFolder)
		(New-Object System.Net.WebClient).DownloadFile($url, $certFilePath)
		Write-Host "Installing the Umbrella Root Cert"
		#& certutil -addstore -enterprise -f "Root" $certFilePath
		Import-Certificate -FilePath $certFilePath -CertStoreLocation Cert:\LocalMachine\Root\
		If(Test-Path "C:\Program Files\Mozilla Firefox\defaults\pref\") {Write-Host "Configuring Firefox to use the Cert";Set-Content "C:\Program Files\Mozilla Firefox\defaults\pref\firefox-windows-truststore.js" "pref('security.enterprise_roots.enabled', true);"}
	} Else {
		Write-Host -ForegroundColor Green "The Umbrella Root Cert is already installed."
	}

	Write-Host "Checking Umbrella DNS client."
	$IsInstalled = Get-Service -Name Umbrella_RC -ErrorAction SilentlyContinue
	If ($IsInstalled) {
		Write-Host -ForegroundColor Green "Umbrella DNS client is already installed. Exiting."
	} Else {
		Write-Host "Installing Umbrella DNS client."
		$PreDNS = (Get-NetIPConfiguration | Where {$_.Netprofile.Ipv4Connectivity -Like "*Internet*"}).DnsServer.ServerAddresses
		Write-Host "DNS Servers: $PreDNS"
		#Dowload config file index
		$SiteConfigs = @()
		$SiteConfigs = (Invoke-WebRequest -uri "https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Umbrella/UDNS-Client-Mapping.csv" -UseBasicParsing).Content | convertfrom-csv -Delimiter ','
		$MSIUrl = "https://cisco-umbrella-client-downloads.s3.amazonaws.com/win/production/Setup.msi"

		Function InstallAgent {
			Write-Host
			Write-Host ================ Agent Installation ================
			Write-Host Downloading the agent for $SelectedSite.Site
			$msiFolder = $ENV:SystemDrive + '\Ambitions\UmbrellaClient\'
			$msiFilePath = $msiFolder + 'Setup.msi'
			$Command = $SelectedSite.Command

			$null = (New-Item -ItemType Directory -Force -Path $msiFolder)
			If (Test-Path $msiFilePath) { Remove-Item $msiFilePath}
			(New-Object System.Net.WebClient).DownloadFile($MSIUrl, $msiFilePath)
			Get-Item $msiFilePath | Unblock-File
			#Write-Host Disabling Windows Defender Real Time Scanning
			#Set-MpPreference -DisableRealtimeMonitoring $True -ErrorAction SilentlyContinue
			Write-Host Installing the agent for $SelectedSite.Site
			Set-Location -Path $msiFolder
			$Command | Invoke-Expression | Wait-Process
			Start-Sleep -Seconds 30
			$PostDNS = (Get-NetIPConfiguration | Where {$_.Netprofile.Ipv4Connectivity -Like "*Internet*"}).DnsServer.ServerAddresses
			Write-Host "DNS Servers: $PostDNS"
			BREAK
		} #End of InstallAgent

		Function Show-Menu {
			param (
				[string]$Title = 'Site Selection'
			)
			Clear-Host
			Write-Host "Umbrella DNS Agent Installer"
			Write-Host
			Write-Host "================ $Title ================"
			Foreach ($Site in $SiteConfigs) {
				Write-Host "Enter "$Site.Code"`t for "$Site.Site
			}
			Write-Host "Enter 'Q' to quit"
			Write-Host
		} #End of Show-Menu

		Function Create-Menu {
			$selection = $null
			Do {
				Show-Menu -Title 'Site Selection'
				If (!($selection)) { $selection = Read-Host "Please make a selection" }
				$SelectedSite = $SiteConfigs.Where( { $PSItem.Code -like $selection })
				If ($selection -eq 'q') { Break }
				If ($SelectedSite) {
					Write-Host
					Write-Host Selection Confirmed: $SelectedSite.Site
					InstallAgent
				} Else {
					$selection = Read-Host "Invalid code. Please make a valid selection"
				}
			}
			Until ($selection -eq 'q')
		} #End of Create-Menu

		# Check for preassigned site code, offer choices If not
		If (Get-Variable -Name SiteCode -ErrorAction SilentlyContinue) { $Code = $SiteCode ; $Silent = $True }
		If ($Code) {
			$SelectedSite = $SiteConfigs.Where( { $PSItem.Code -like $code })
			If ($SelectedSite) {
				InstallAgent
			} Else {
				Do {
					Show-Menu -Title 'Site Selection'
					$selection = Read-Host "Invalid code. Please make a valid selection"
				}
				Until ($selection -eq 'q')
			}
		} Else {
			Write-Host "Attempting to determine location"
			$DetectedIP = (Invoke-WebRequest -uri "http://ip.ambitionsgroup.com/" -UseBasicParsing).Content
			$searchterm = '*' + $DetectedIP + '*'
			$DetectedSite = $SiteConfigs.Where( { $PSItem.ExtIPs -like $searchterm })
			If ($DetectedSite) {
				$DetectedCode = $DetectedSite.Code
				$DetectedTitle = $DetectedSite.Site

				If ($Auto) {
					#Silently install automatically
					Write-Host Automatic mode, hold on!
					$SelectedSite = $DetectedSite
					$Silent = $True
					InstallAgent
				} Else {
					#Prompt for auto install
					$message = "Based on your external IP address of $DetectedIP, you are at $DetectedTitle"
					$question = 'Do you want to proceed installing the agent for this site?'
					$choices = New-Object Collections.ObjectModel.Collection[Management.Automation.Host.ChoiceDescription]
					$choices.Add((New-Object Management.Automation.Host.ChoiceDescription -ArgumentList '&Yes'))
					$choices.Add((New-Object Management.Automation.Host.ChoiceDescription -ArgumentList '&No'))
					$decision = $Host.UI.PromptForChoice($message, $question, $choices, 0)
					If ($decision -eq 0) {
						Write-Host "Selection Confirmed: $DetectedTitle"
						$SelectedSite = $DetectedSite
						InstallAgent
						BREAK
					} Else {
						Write-Host Generating a site selection menu
						Create-Menu
					}
					#Pause
				}
			} Else {
				Write-Host No site detected based on your external IP address
				Create-Menu
			}
		}
	}
}

Function Install-WinGet {
<#
	.SYNOPSIS
		Installs winget, Microsoft's answer to apt-get and choco.
	.LINK
		https://github.com/microsoft/winget-cli
	.LINK
		https://docs.microsoft.com/en-us/windows/package-manager/winget/
#>
	$WGLatestWeb = iwr https://github.com/microsoft/winget-cli/releases/latest -UseBasicParsing
	$WGLatestLink = "https://github.com" + ($WGLatestWeb.Links | Where-Object {$_.href -like "*msixbundle*"}).href

	$GetWinGet = {
		$WGLatestWeb = iwr https://github.com/microsoft/winget-cli/releases/latest -UseBasicParsing
		$WGLatestLink = "https://github.com" + ($WGLatestWeb.Links | Where-Object {$_.href -like "*msixbundle*"}).href
		Write-Host "Installing the latest version of winget from:`n $WGLatestLink"
		$DownloadURL = $WGLatestLink
		$DownloadLocation = "$env:TEMP\"
		$LocalFilePath = Join-Path -Path $DownloadLocation -ChildPath "Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
		If (Test-Path $LocalFilePath) {Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue}
		Write-Host "Downloading Desktop App Installer"
		$progressPreference = 'silentlyContinue'
		Invoke-WebRequest -Uri $DownloadURL -OutFile $LocalFilePath

		Add-AppxPackage -Path $LocalFilePath
		Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue
	}

	$GetWinGetDependancies = {
		Write-Host "Checking Dependancies"
		## C++ Runtime framework packages for Desktop Bridge - https://docs.microsoft.com/en-us/troubleshoot/cpp/c-runtime-packages-desktop-bridge#how-to-install-and-update-desktop-framework-packages
		## x86 version
		$Installed_X86_VCLibs = Get-AppxPackage | Where-Object {$_.Name -Match "Microsoft.VCLibs.140.00.UWPDesktop" -and $_.Architecture -Match "X86"}
		If (-not ($Installed_X86_VCLibs)) {
			$DownloadURL = 'https://aka.ms/Microsoft.VCLibs.x86.14.00.Desktop.appx'
			$DownloadLocation = "$env:TEMP\"
			$LocalFilePath = Join-Path -Path $DownloadLocation -ChildPath "Microsoft.VCLibs.x86.14.00.Desktop.appx"
			If (Test-Path $LocalFilePath) {Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue}
			Write-Host "Downloading $DownloadURL"
			$progressPreference = 'silentlyContinue'
			Invoke-WebRequest -Uri $DownloadURL -OutFile $LocalFilePath
			If ($PSVersionTable.PSEdition -eq "Core") {Import-module "Appx" -UseWindowsPowerShell}
			Write-Host "Installing $LocalFilePath"
			Add-AppxPackage -Path $LocalFilePath
			Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue
		}
		## x64 version
		If ([Environment]::Is64BitOperatingSystem){
			$Installed_X64_VCLibs = Get-AppxPackage | Where-Object {$_.Name -Match "Microsoft.VCLibs.140.00.UWPDesktop" -and $_.Architecture -Match "X64"}
			If (-not ($Installed_X64_VCLibs)) {
				$DownloadURL = 'https://aka.ms/Microsoft.VCLibs.x64.14.00.Desktop.appx'
				$DownloadLocation = "$env:TEMP\"
				$LocalFilePath = Join-Path -Path $DownloadLocation -ChildPath "Microsoft.VCLibs.x64.14.00.Desktop.appx"
				If (Test-Path $LocalFilePath) {Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue}
				Write-Host "Downloading $DownloadURL"
				$progressPreference = 'silentlyContinue'
				Invoke-WebRequest -Uri $DownloadURL -OutFile $LocalFilePath
				If ($PSVersionTable.PSEdition -eq "Core") {Import-module "Appx" -UseWindowsPowerShell}
				Write-Host "Installing $LocalFilePath"
				Add-AppxPackage -Path $LocalFilePath
				Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue
			}
		}
	}

	If ($(whoami) -eq "nt authority\system") {
		Write-Error "Due to the AppX nature of Winget, you cannot run this as the system user"
	} ElseIf (!(Get-process -Name Explorer -IncludeUserName | Where-Object -Property UserName -EQ $(whoami))){
		Write-Error "Due to the AppX nature of Winget, you cannot install WinGet when running the command as a user that is not logged in"
	} Else {
# Install WinGet
		If (Get-Command winget -ErrorAction SilentlyContinue) {
			Write-Host "WinGet is already installed."
			$WGVersion = winget -v
			If ($WGLatestLink -match $WGVersion) {
				Write-Host "The installed version $WGVersion is up to date."
			} Else {
				Write-Host "The installed version $WGVersion is out of date."
				If ($PSVersionTable.PSEdition -eq "Core") {Powershell.exe -NonInteractive -Command $GetWinGet} Else {$GetWinGet | IEX}
				$WGVersion2 = winget -v
				If ($WGVersion -ne $WGVersion2) {
					Write-Host "Winget $WGVersion2 installed successfully"
				} Else {
					Write-Error "Winget did not install successfully"
				}
			}
		} Else {
			Write-Host "WinGet is not installed."
			If ($PSVersionTable.PSEdition -eq "Core") {Powershell.exe -NonInteractive -Command $GetWinGetDependancies} Else {$GetWinGetDependancies | IEX}
			If ($PSVersionTable.PSEdition -eq "Core") {Powershell.exe -NonInteractive -Command $GetWinGet} Else {$GetWinGet | IEX}
			If (Get-Command winget -ErrorAction SilentlyContinue) {
				$WGVersion = winget -v
				Write-Host "Winget $WGVersion installed successfully"
			} Else {
				Write-Error "Winget did not install successfully"
			}
		}
	}
}

Function Install-WinGetApps {
	Install-WinGet
	Winget install -e --id 7zip.7zip -h
	Winget install -e --id Google.Chrome -h
	Winget install -e --id Mozilla.FirefoxESR -h
	Winget install -e --id Zoom.Zoom -h
	Winget install -e --id Notepad++.Notepad++ -h
	Winget install -e --id Adobe.AdobeAcrobatReaderDC -h
	Winget install -e --id VideoLAN.VLC -h
	Winget install -e --id Microsoft.PowerShell -h
}

Function Install-WinRepairToolbox {
	Write-Host "Downloading Windows Repair Toolbox"
		$URL = 'https://windows-repair-toolbox.com/files/Windows_Repair_Toolbox.zip'
		$DLFolder = $ENV:SystemDrive + '\Ambitions\Windows_Repair_Toolbox'
		$DLFilePath = $DLFolder + '\Windows_Repair_Toolbox.zip'
		$null = (New-Item -ItemType Directory -Force -Path $DLFolder)
		(New-Object System.Net.WebClient).DownloadFile($url, $DLFilePath)
	Write-Host "Expanding Windows Repair Toolbox"
		Expand-Archive -Path $DLFilePath -DestinationPath $DLFolder -Force
	Write-Host "Downloading Windows Repair Toolbox Customizations"
		$URL = 'https://download.ambitionsgroup.com/Software/Windows_Repair_Toolbox_Custom.zip'
		$CustomizationFilePath = $DLFolder + '\Windows_Repair_Toolbox_Custom.zip'
		$null = (New-Item -ItemType Directory -Force -Path $DLFolder)
		(New-Object System.Net.WebClient).DownloadFile($url, $CustomizationFilePath)
	Write-Host "Customizing Windows Repair Toolbox"
		Expand-Archive -Path $CustomizationFilePath -DestinationPath $DLFolder -Force
	Write-Host "Cleaning up downloaded files"
	Remove-Item -Path $DLFilePath -Force
	Remove-Item -Path $CustomizationFilePath -Force
	"& $($DLFolder + '\Windows_Repair_Toolbox.exe')" | Clip
	Write-Host "The command to launch Windows Repair Toolbox has been put in your clipboard."
}

Function Invoke-Win10Decrap {
	Write-Host "Windows 10 Decrapifier"
	$progressPreference = 'silentlyContinue'
	Set-ExecutionPolicy Bypass -Scope Process -Force
	Enable-SSL
	Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Win-10-DeCrapifier/Windows10Decrapifier.txt -UseBasicParsing | Invoke-Expression
}

Function Join-Domain {
		param
	(
		[Parameter(Mandatory=$true)]
		[string]$Domain,
		[Parameter(Mandatory=$true)]
		[string]$Username,
		[Parameter(Mandatory=$true)]
		$Password
	)
	Write-Host "Join Domain"
	$Password = $Password | ConvertTo-SecureString -asPlainText -Force
	$Username = $Domain + "\" + $Username
	$credential = New-Object System.Management.Automation.PSCredential($Username,$Password)
	Add-Computer -DomainName $Domain -Credential $credential
}

Function Remove-ITS247InstallFolder {
	Write-Host "Cleaning up install folder"
	Remove-PathForcefully -Path 'C:\Ambitions\ITS247Agent'
}

Function Optimize-Powershell {
	$Commands = @()
	$Commands = {
	Function prompt {
			$date = Get-Date
			$time = $date.GetDateTimeFormats()[88]
			$curdir = $ExecutionContext.SessionState.Path.CurrentLocation #.Path.Split('\')[-1]
			If ($curdir.Length -eq 0) {$curdir = $ExecutionContext.SessionState.Drive.Current.Name+':\'}
			Write-Host ''$env:USERNAME'@'$env:COMPUTERNAME' |' -NoNewLine -BackgroundColor Black -ForegroundColor Yellow
			Write-Host ' DIR:'$curdir' |' -NoNewLine -BackgroundColor Black -ForegroundColor Yellow
			Write-Host ''$time' ' -BackgroundColor Black -ForegroundColor Yellow
			'[Command]: '
		}
		iwr ps.acgs.io -useb  | iex
		cls
		Write-Host "`n`nWelcome Ambitions TechGod, I await your command...`n`n"
	}
	#Source code can be found at: https://github.com/Microsoft/Terminal/tree/master/src/tools/ColorTool
	$DownloadURL = "https://raw.githubusercontent.com/waf/dracula-cmd/master/dist/ColorTool.zip"
	$DownloadLocation = "C:\Ambitions\ColorTool"
	$DownloadFile = "$($DownloadLocation)\ColorTool.zip"
	$InstallExe = Join-Path -Path $DownloadLocation -ChildPath "\ColorTool\install.cmd"
	
	Try {
		If (!$(Test-Path $InstallExe)) {
			#Write-Host "Preparing Internet Health Test."
			New-Item $DownloadLocation -ItemType Directory -force
			Invoke-WebRequest -Uri $DownloadURL -OutFile $DownloadFile
			Expand-Archive $DownloadFile -DestinationPath $DownloadLocation -Force
			$Content = Get-Content $InstallExe
			$Content | Foreach-Object {$_ -replace [regex]::escape('pause'), ''} | Set-Content $InstallExe
			& $InstallExe
			$NewCommands = (Invoke-WebRequest https://raw.githubusercontent.com/dracula/powershell/master/theme/dracula-prompt-configuration.ps1 -UseBasicParsing).Content #
			$Commands = $Commands ; $NewCommands
			$Commands | Set-Content $Profile
			$Null = New-ItemProperty -LiteralPath 'HKCU:\Console' -Name 'FaceName' -Value 'Consolas' -PropertyType String -Force -ea SilentlyContinue
		}
	} Catch {
		Write-Host "The download and extraction of ColorTool failed. Error: $($_.Exception.Message)"
		#exit 1
		Return
	}
	Start-Process C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ArgumentList "-NoExit -Mta -WindowStyle Maximized -Command $Commands"
}

Function Remove-PathForcefully {
	param(
		[parameter(Mandatory=$true)]
		[string] $Path
	)
	<# the code below has been used from
		- https://blogs.technet.com/b/heyscriptingguy/archive/2013/10/19/weekend-scripter-use-powershell-and-pinvoke-to-remove-stubborn-files.aspx
	with inspiration from
		- http://www.leeholmes.com/blog/2009/02/17/moving-and-deleting-really-locked-files-in-powershell/
	and error handling from
		- https://blogs.technet.com/b/heyscriptingguy/archive/2013/06/25/use-powershell-to-interact-with-the-windows-api-part-1.aspx
	#>
	Add-Type -ErrorAction Ignore @'
		using System;
		using System.Text;
		using System.Runtime.InteropServices;

		public class Posh
		{
			public enum MoveFileFlags
			{
				MOVEFILE_DELAY_UNTIL_REBOOT = 0x00000004
			}

			[DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
			static extern bool MoveFileEx(string lpExistingFileName, string lpNewFileName, MoveFileFlags dwFlags);

			public static bool MarkFileDelete (string sourcefile)
			{
				return MoveFileEx(sourcefile, null, MoveFileFlags.MOVEFILE_DELAY_UNTIL_REBOOT);
			}
		}
'@
	Function Remove-SubPath {
		param(
			[parameter(Mandatory=$true)]
			[string] $SubPath
		)


		$SubPath = (Resolve-Path $SubPath -ErrorAction Stop).Path
		try {
			Remove-Item $SubPath -Force -Recurse -ErrorAction Stop
			Write-Host -ForegroundColor Green -BackgroundColor Black "Deletion of $SubPath succeeded."
		} catch {
			$deleteResult = [Posh]::MarkFileDelete($SubPath)
			if ($deleteResult -eq $false) {
				throw (New-Object ComponentModel.Win32Exception) # calls GetLastError
			} else {
				Write-Host -ForegroundColor Red -BackgroundColor Yellow "Deletion of ||$SubPath|| failed. Deleting at next boot."#`n$($_.Exception.Message)"
			}
		}
	}
	If (Test-Path -Path $Path -Verbose) {
		$SubFiles = Get-ChildItem -Path $Path -Recurse -Force -File
		$SubFolders = Get-ChildItem -Path $Path -Recurse -Force -Directory
		If ($SubFiles -or $SubFolders) {
			$SubFiles | ForEach-Object {Remove-SubPath -SubPath $_.FullName}
			$SubFolders | ForEach-Object {Remove-SubPath -SubPath $_.FullName}
			Remove-SubPath -SubPath $Path
		} Else {
			Remove-SubPath -SubPath $Path
		}
	} Else {
		Write-Warning "$Path was not found."
	}
	<#
	.SYNOPSIS
		Deletes all files and folders given immediately if they are not locked.
		If locked files are found, queues them up to be deleted upon next reboot.
		Recurse is assumed.
	.PARAMETER Path
		The file system path of the folder or file to be deleted.
	.EXAMPLE
		Remove-PathForcefully -Path "C:\Temp" # Deletes the folder C:\Temp and all files or folders within, queuing up any locked files for deletion on next reboot.
	#>
}

Function Rename-ClientComputer {
	Write-Host "Rename Computer"
		$title = 'Rename Computer'
		$msg = 'Enter the client shortcode (e.g. AAIHB) or Dept code'
		$SerialNumber = (Get-WmiObject win32_bios).SerialNumber
		#Message box prompts onscreen for input
		[void][Reflection.Assembly]::LoadWithPartialName('Microsoft.VisualBasic')
		$ClientCode = [Microsoft.VisualBasic.Interaction]::InputBox($msg, $title)
		Rename-Computer ($ClientCode + "-" + $SerialNumber) -Force
	Write-Host "End of Rename Computer"
}

Function Repair-O365AppIssues {
	Write-Host "Please note this is an interactive tools, to be run from a user's session."
	If (-not (Test-Path 'C:\Ambitions')) {New-Item -ItemType Directory -Force -Path C:\Ambitions\ | Out-Null}
	(New-Object System.Net.WebClient).DownloadFile('https://aka.ms/SaRASetup', 'C:\Ambitions\SaraSetup.exe')
	& C:\Ambitions\SaraSetup.exe
	Write-Host "SaRA should now be installing, please wait a moment as it launces."
<#
	.SYNOPSIS
		Downloads and runs the Microsoft Support and Recovery Assistant (SaRA) tool.
		Please note this is an interactive tools, to be run from a user's session.
	.LINK
		https://www.thewindowsclub.com/microsoft-support-and-recovery-assistant
	.LINK
		https://www.microsoft.com/en-us/download/100607
#>
}

Function Repair-Windows {
	$StartTime = (Get-Date)
	(Get-Date).DateTime | Out-Host
	Write-Host Repair-Volume -DriveLetter $Env:SystemDrive.SubString(0,1) -Scan
	$chdksk = Repair-Volume -DriveLetter $Env:SystemDrive.SubString(0,1) -Scan
	If ($chdksk -ne "NoErrorsFound") {Repair-Volume -DriveLetter $Env:SystemDrive.SubString(0,1) -SpotFix}
	Write-Host Dism /Online /Cleanup-Image /StartComponentCleanup
	Dism /Online /Cleanup-Image /StartComponentCleanup
	Write-Host ...
	(Get-Date).DateTime | Out-Host
	Write-Host Dism /Online /Cleanup-Image /RestoreHealth
	Dism /Online /Cleanup-Image /RestoreHealth
	Write-Host ...
	(Get-Date).DateTime | Out-Host
	Write-Host SFC /scannow
	SFC /scannow
	(Get-Date).DateTime | Out-Host
	$EndTime = (Get-Date) - $StartTime
	Write-Host "This process took:"
	$EndTime | FT | Out-Host
	Write-Host "Run this function repeately until no errors show up. If this fails after 3 tries, upgrade or reinstall windows"
}

Function Restore-LastUser {
	$RegKey = "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI"
	$RegKeyPS = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI"
	$RegFile = "C:\Ambitions\LastLoggedOnUser.reg"
	$InitUser = (Get-ItemProperty $RegKeyPS).LastLoggedOnUser

	If (Test-Path -Path $RegFile){
		$User = (Select-String -Path $RegFile -Pattern '"LastLoggedOnUser"' -SimpleMatch).Line
		Write-Host "Restoring:`n$User"
		REG IMPORT $RegFile
		$NewUser = (Get-ItemProperty $RegKeyPS).LastLoggedOnUser
		Write-Host "Last Logged On User has been restored from $InitUser to $NewUser"
		Write-Host "Refreshing the Logon Screen."
		Get-Process -Name LogonUI -ErrorAction SilentlyContinue | Stop-Process -Force
	} Else {
		Write-Host "Error: No backup exists. Try the command Backup-LastUser to create a backup."
	}
}

Function Set-AutoLogon ([String] $SiteCode) {
	Write-Host "Set autologon"
		#Registry path declaration
		$RegPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
		[String]$DefaultUsername = 'ATGLocal'
		[String]$DefaultPassword = $SiteCode + 'T3mpP@ss'
		#setting registry values
		Set-ItemProperty $RegPath "AutoAdminLogon" -Value "1" -type String
		Set-ItemProperty $RegPath "DefaultUsername" -Value $DefaultUsername -type String
		Set-ItemProperty $RegPath "DefaultPassword" -Value $DefaultPassword -type String
		Set-ItemProperty $RegPath "AutoLogonCount" -Value "1" -type DWord
	Write-Host "End of Set autologon"
}

Function Set-DailyReboot {
<#
	.SYNOPSIS
		Creates a scheduled task to restart the computer daily at 3am, if no one is using the computer.
		Helpful for maintaining updated and stability.
#>
	Write-Host "Schedule Daily Restart"
		$Action = New-ScheduledTaskAction -Execute 'shutdown.exe' -Argument '-f -r -t 0'
		$Trigger = New-ScheduledTaskTrigger -Daily -At 3am
		$Idle = New-ScheduledTaskSettingsSet -RunOnlyIfIdle -IdleDuration 00:30:00 -IdleWaitTimeout 02:00:00
		$User = "NT AUTHORITY\SYSTEM"
		Register-ScheduledTask -Action $action -Trigger $trigger -User $User -Settings $Idle -TaskName "Daily Restart" -Description "Daily restart" -Force | Out-Null
		$NewDate = (Get-ScheduledTask -TaskName "Daily Restart").Triggers.StartBoundary.subString(0,16)
	Write-Host "The next scheduled 'Daily Restart' task will happen at $([Datetime]::ParseExact($NewDate, 'yyyy-MM-ddTHH:mm', $null))"
}

Function Set-DailyRebootDelay {
<#
	.SYNOPSIS
		Delays the "Daily Restart" scheduled task by the specified numer of days
	.PARAMETER Days
		The number of days to delay the reboot
	.EXAMPLE
		'Set-DailyRebootDelay -Days 80' will delay nightly reboots for 80 days!
#>
	param
	(
		[Parameter(Mandatory=$true)]
		[Int32]$Days
	)
	$DailyRebootTask = Get-ScheduledTask -TaskName "Daily Restart" -ErrorAction SilentlyContinue
	If (! $DailyRebootTask) {
		Set-DailyReboot
	}
	$DelayedStart = (Get-Date).AddDays($Days).ToString('yyyy-MM-dd') + "T03:00:00-06:00"
	$Trigger = New-ScheduledTaskTrigger -Daily -At 3am
	$Trigger.StartBoundary = $DelayedStart
	$DailyRebootTask.Triggers = $Trigger
	$DailyRebootTask | Set-ScheduledTask | Out-Null
	$NewDate = (Get-ScheduledTask -TaskName "Daily Restart").Triggers.StartBoundary.subString(0,16)
	Write-Host "The next scheduled 'Daily Restart' task will happen at $([Datetime]::ParseExact($NewDate, 'yyyy-MM-ddTHH:mm', $null))"
}

Function Set-MountainTime {
	Write-Host "Setting local time zone to Mountain Time"
	Set-TimeZone -Name "Mountain Standard Time"
	net start W32Time
	W32tm /resync /force
}

Function Set-NumLock {
	Write-Host "Setting Numlock on keyboard as default"
	Set-ItemProperty -Path 'Registry::HKU\.DEFAULT\Control Panel\Keyboard' -Name "InitialKeyboardIndicators" -Value "2" -Force -PassThru
}

Function Set-RunOnceScript {
	param
	(
		[string]$Label,
		[string]$Script
	)

	$RunOnceValue = 'PowerShell.exe -ExecutionPolicy Bypass -File "' + $Script + '"'
	Write-Host "Install After Reboot"
	Set-ItemProperty 'HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce' -Name $Label -Value $RunOnceValue
}

Function Start-PPKGLog ([String] $LogLabel) {
	Write-Host "Making a log file for debugging"
		$LogPath = "C:\Ambitions\" + $SiteCode + "-" + $LogLabel + ".log"
		Start-Transcript -path $LogPath -Force -Append
}

Function Start-ServerMaintenance {
	If ($PSVersionTable.PSEdition -eq "Desktop") {
		If (-Not (Get-Command "pwsh" -ErrorAction SilentlyContinue)) { Update-PWSH }
		pwsh -Command {(Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Maintenance-Checks/Server-Maintenance-Checks.txt -UseBasicParsing).Content | Invoke-Expression}
	} Else {
		(Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Maintenance-Checks/Server-Maintenance-Checks.txt -UseBasicParsing).Content | Invoke-Expression
	}
}

Function Uninstall-UmbrellaDNS {
	$IsInstalled = Get-Service -Name Umbrella_RC -ErrorAction SilentlyContinue
	$PreDNS = (Get-NetIPConfiguration | Where {$_.Netprofile.Ipv4Connectivity -Like "*Internet*"}).DnsServer.ServerAddresses
	If ($IsInstalled) {
		Write-Host "DNS Servers: $PreDNS"
		Write-Host "Umbrella DNS Client found. Initiating uninstall..."
		wmic.exe Product where "name='Umbrella Roaming Client'" call uninstall
		$PostDNS = (Get-NetIPConfiguration | Where {$_.Netprofile.Ipv4Connectivity -Like "*Internet*"}).DnsServer.ServerAddresses
		Write-Host "DNS Servers: $PostDNS"

		Write-Host "Checking Root Certificate"
		$CAHASH = "C5091132E9ADF8AD3E33932AE60A5C8FA939E824" #Thumbprint of the Cert set to expire in 2036
		$RootCertPath = "Cert:\LocalMachine\Root\$CAHASH"
		$CertInstalled = Get-Item -Path $RootCertPath
		If ((Test-Path $RootCertPath -ea SilentlyContinue)) {
			Write-Host "Uninstalling the Umbrella Root Cert"

			$CertInstalled | Remove-Item -Force
			If(Test-Path "C:\Program Files\Mozilla Firefox\defaults\pref\") {Write-Host "Configuring Firefox settings.";Set-Content "C:\Program Files\Mozilla Firefox\defaults\pref\firefox-windows-truststore.js" "pref('security.enterprise_roots.enabled', false);"}
		} Else {
			Write-Host -ForegroundColor Green "The Umbrella Root Cert is not installed."
		}

		Write-Host "Checking Status Indicator"
		$IndicKey = Get-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\NetworkConnectivityStatusIndicator | Select-Object -ExpandProperty UseGlobalDNS -ea SilentlyContinue
		If ($IndicKey -eq 1) {
			Write-Host "Removing Connectivity Indicator Reg Key"
			Remove-ItemProperty -LiteralPath 'HKLM:\SOFTWARE\Policies\Microsoft\Windows\NetworkConnectivityStatusIndicator' -Name 'UseGlobalDNS' -Force -ea SilentlyContinue
		} Else {
			Write-Host -ForegroundColor Green "The Status Indicator not present."
		}
	} Else {
		Write-Host "DNS Servers: $PreDNS"
		Write-Host "Umbrella DNS Client not found."
	}
}

Function Update-DattoAgent {
	Enable-SSL
	$progressPreference = 'silentlyContinue'
	iwr https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Datto-Agent-Update/DattoAgentUpdate.txt -usebasicparsing | iex
}

Function Update-DellPackages {
	<#
	.SYNOPSIS
		Uses the CLI version of Dell Command | Update to install any missing drivers/firmwares/Bios and update existing ones.
		There are no parameters to use.
	.LINK
		https://www.dell.com/support/kbdoc/en-us/000177325/dell-command-update
	.EXAMPLE
		Update-DellPackages
	#>

	Write-Host "Dell Updates"
		$Manufact = (Get-CimInstance -Class Win32_ComputerSystem).Manufacturer
		If ( $Manufact -like "*Dell*") {
			#Install and update Chocolatey if Needed
			If (Get-Command choco -errorAction SilentlyContinue) {
				choco upgrade chocolatey -y
			} Else { Install-Choco }

			Function Install-DCU {
				#Starts the IPMI Service if needed
				$IPMIService = (Get-Service -Name IPMIDRV -ErrorAction SilentlyContinue).Status
				If ($IPMIService -and $IPMIService -ne "Running") {Start-Service -Name IPMIDRV}
				#Install the latest
				Stop-Process -Name DellCommandUpdate -Force -ErrorAction SilentlyContinue
				Choco upgrade dellcommandupdate -y --force --ignorechecksums
			}

			Write-Host "Checking if 'Dell Command Update' is current."
				#Remove any Windows 10 "Apps"
				Get-ProvisionedAppPackage -Online | Where-Object {$_.DisplayName -like "*Dell*Update*"} | Remove-ProvisionedAppPackage -Online
				Get-AppxPackage "*Dell*Update*" | Remove-AppxPackage
				If (Get-AppxPackage *Dell*Update*){
					$apps = Get-ChildItem -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall,HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall | Get-ItemProperty | Where-Object {$_.DisplayName -like "Dell*Update*" } | Select-Object -Property DisplayName, UninstallString
					ForEach ($ver in $apps) {
						If ($ver.UninstallString) {
							$uninst = $ver.UninstallString
							Write-Host Uninstalling: $ver.DisplayName
							Start-Process cmd -ArgumentList "/c $uninst /quiet /norestart" -NoNewWindow -Wait -PassThru
						}
					}
				}

				#Compare version numbers of any remaining installed version.
				$DCUInstalledVersion = (Get-Package -Provider Programs -IncludeWindowsInstaller -Name "Dell Command | Update" -ErrorAction SilentlyContinue).Version
				$DCUAvailableVersion = choco list dellcommandupdate #Gets all results
				$DCUAvailableVersion = ($DCUAvailableVersion | Select-String -Pattern "DellCommandUpdate " -SimpleMatch).Line #Isolates the desired result
				$DCUAvailableVersion = $DCUAvailableVersion.split(" ",[System.StringSplitOptions]::RemoveEmptyEntries)[1] #Isolates the version number

			If (-not $DCUInstalledVersion) {
				Write-Host "'Dell Command Update' is not installed, installing now."
				Install-DCU

			}  ElseIf ($DCUInstalledVersion -ne $DCUAvailableVersion) {
				Write-Host "'Dell Command Update' is not current. Updating from version $DCUInstalledVersion to $DCUAvailableVersion."

				#Remove any programs listed through "Add and remove programs"
				$DCUInstalled = Get-WmiObject -Class Win32_Product | Where-Object {$_.Name -like "*Dell*Update*"}
				If ($DCUInstalled) {
					$DCUInstalled.Uninstall()
				}
				Install-DCU

			} ElseIf ($DCUInstalledVersion -eq $DCUAvailableVersion) {
				Write-Host "'Dell Command Update' is current."
			}

			#Configure and run Dell Command Update
			Stop-Process -Name DellCommandUpdate -Force -ErrorAction SilentlyContinue
			$DCUx86 = Join-Path -Path ${env:ProgramFiles(x86)} -ChildPath "Dell\CommandUpdate\dcu-cli.exe"
			$DCUx64 = Join-Path -Path $Env:ProgramFiles -ChildPath "Dell\CommandUpdate\dcu-cli.exe"
			If (Test-Path $DCUx86) {
				& $DCUx86 /configure -autoSuspendBitLocker=enable
				& $DCUx86 /applyUpdates -reboot=disable
			} ElseIf (Test-Path $DCUx64) {
				& $DCUx64 /configure -autoSuspendBitLocker=enable
				& $DCUx64 /applyUpdates -reboot=disable
			} Else { Write-Error "Dell Command Update CLI not found."}

		} Else { Write-Host "This is not a Dell Computer" }
	Write-Host "`nEnd of Dell Updates"
}

Function Update-DellServer {
	Write-Host "Please note, this is a draft. Report errors to Ryan."
	Write-Warning "Update-Everything will have a visible impact to any logged in users,`nas it will update drivers and reboot the computer.`nYou have 10 seconds to press CTRL+C to cancel this function."
	$delay = 10

	while ($delay -ge 0)
	{
	  Write-Host "$delay seconds left to cancel"
	  Start-Sleep 1
	  $delay --
	}
	$delay = $null
	
	$URL = "https://dl.dell.com/FOLDER07525263M/1/Systems-Management_Application_5C2CW_WN64_1.9.2.0_A00.EXE"
	$File = "C:\Ambitions\Dell System Update 1.9.2.exe"
	$Hash = '2905a5c8717a9806f76fa88af340fd4747a45c5bd846849ec0bd336ece7f6cbe'
	Function Get-DSUInstall {
		Write-Host "Dell System Update is not installed, attempting to install."
		Write-Host "Download the installer to $File"
		(New-Object System.Net.WebClient).DownloadFile($URL,$File) #Download the URL to the File.
				Write-Host "Download is complete, checking the integrity."
	}

	Function Test-DSUInstall {	IF ((Get-FileHash -Path $File -Algorithm SHA256).Hash -eq $Hash) {
			Write-Host "It's a match!"
		} Else {
			Write-Host "Uh oh, there were issues downloading a non-corrupt file. Please attempt manually."
			Write-Host "Download is available at https://www.dell.com/support/home/en-us/drivers/driversdetails?driverid=8ctk7"
			Pause
			Exit
		}
	}

	Function Install-DSU {
		Write-Host "Attempting to install the program."
		& $File /f /s /i | Wait-Process -ErrorAction SilentlyContinue
	}

	Write-Host "Dell System Updates"
	$Manufact = (Get-CimInstance -Class Win32_ComputerSystem).Manufacturer
	$OSVersion = (get-itemproperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -Name ProductName).ProductName
	If( $Manufact -NotLike "*Dell*")
	{
		Write-Host "This is not a Dell Computer"
		Pause
		Exit
	} Else {
		If ( $OSVersion -NotLike "*Server*") {
			Write-Host "This is not a Server."
			Pause
			Exit
		} Else {
			Write-Host "Checkin if DSU is installed"
			If ((Get-WmiObject win32_product | Where-Object -Property Name -Like "*Dell EMC System Update*").Version -NotLike "1.9.2*") {
				Write-Host "Dell System Update is either not installed or not version 1.9.2"
				Get-DSUInstall
				Test-DSUInstall
				Install-DSU
			} Else {
				Write-Host "DSU is already installed."
			}

			Write-Host "Installing Dell System Updates"
			& "C:\Program Files\Dell\Dell EMC System Update\DSU.exe" /d /u /n
		}
	}
}

Function Update-Edge {
	Write-Host "Updating Microsoft Edge"
	If (!(Get-Command choco -ErrorAction SilentlyContinue)) {Install-Choco}
	If (Get-Process MicrosoftEdge -ErrorAction SilentlyContinue) {Get-Process MicrosoftEdge | Stop-Process -Force}
	Choco upgrade microsoft-edge -y
}

Function Update-Everything {
	Write-Warning "Update-Everything will have a visible impact to any logged in users,`nas it will update drivers and reboot the computer.`nYou have 10 seconds to press CTRL+C to cancel this function."
	$delay = 10

	while ($delay -ge 0)
	{
		Write-Host "$delay seconds left to cancel"
		Start-Sleep 1
		$delay --
	}
	$delay = $null
	If (!(Get-Command choco -ErrorAction SilentlyContinue)) {choco upgrade all -y}
	Update-Windows
	Update-DellPackages
	Update-Edge
	Update-NiniteApps
	Update-PWSH
	Restart-Computer -Force
}

Function Update-ITS247Agent {
	$DisplayVersion = (Get-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\SAAZOD).DisplayVersion
	$TYPE = (Get-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\SAAZOD).TYPE
	$AvailableVersion = ((Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/ITS247Agent/DPMAVersion.txt -UseBasicParsing).Content).Trim()

	If(($DisplayVersion -ne $AvailableVersion) -and ($TYPE -eq "DPMA")) {
	 WRITE-HOST "Updating Agent from $DisplayVersion to $AvailableVersion"
		 $SaveFolder = 'C:\Ambitions'
		 New-Item -ItemType Directory -Force -Path $SaveFolder
		 $PatchPath = $SaveFolder + '\DPMAPatch' + $AvailableVersion + '.exe'
		 (New-Object System.Net.WebClient).DownloadFile('http://update.itsupport247.net/agtupdt/DPMAPatch.exe', $PatchPath)
		 & $PatchPath | Wait-Process
		 $DisplayVersion = (Get-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\SAAZOD).DisplayVersion
	 WRITE-HOST "Agent is now version $DisplayVersion"
	}

	If(($DisplayVersion -eq $AvailableVersion) -and ($TYPE -eq "DPMA")) {
	 WRITE-HOST "Agent appears to be up to date at version $DisplayVersion"
	}
<#
	.SYNOPSIS
		Updates the Continuum ITS247 Desktop agent to the latest available. No parameters are needed.
#>
}

Function Update-NiniteApps {
	<#
	.SYNOPSIS
		Uses NinitePro to immediately update all applications it is cabable of updating. The log will be at C:\Ambitions\NiniteReport.txt
	#>
	If (-not (Test-Path 'C:\Ambitions\NinitePro.exe')) {Install-NinitePro}
	Write-Host "Install Ninite Apps, waiting for install to complete and logging the results."
		$NiniteCache = "\\adsaltoxl\data\Software\Ninite\NiniteDownloads"
		If(test-path $NiniteCache){
			& C:\Ambitions\NinitePro.exe /updateonly /cachepath $NiniteCache /silent 'C:\Ambitions\NiniteReport.txt' | Wait-Process
		} ELSE {
			& C:\Ambitions\NinitePro.exe /updateonly /nocache /silent 'C:\Ambitions\NiniteReport.txt' | Wait-Process
		}
	Get-Content 'C:\Ambitions\NiniteReport.txt'
	Write-Host "End of Install Ninite Apps"
}

Function Update-O365Apps {
	$global:O365CurrentCdn = ""
	If (-not (Test-Path 'C:\Program Files\Common Files\Microsoft Shared\ClickToRun\OfficeC2RClient.exe')) {
		Write-Host "Office 365 Click2Run is not installed. This script does not apply."
	} Else {
		$Apps = @('Excel','Outlook','WinWord','PowerPoint','MsAccess','MSPub','OneNote')
		$OpenApps = @('')
		$Apps | ForEach-Object {
			If (Get-Process $_ -ErrorAction SilentlyContinue) {
				$OpenApps = $OpenApps += $_
			}
		}

		If ($OpenApps) {
			Write-Host "Aborting update, the following Office Apps are open:"
			$OpenApps | FL | Out-String
			Write-Host "Please close these programs and try again."
			} Else {
			Function Get-Office365Version {
				$O365CurrentVer = ""
				$O365CurrentCdn = ""
				$O365CurrentPol = ""
				$O365CurrentVer = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Office\ClickToRun\Configuration" -ErrorAction SilentlyContinue).VersionToReport
				$O365CurrentCdn = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Office\ClickToRun\Configuration" -ErrorAction SilentlyContinue).CDNBaseUrl
				$O365CurrentPol = (Get-ItemProperty -Path "HKLM:\SOFTWARE\policies\microsoft\office\16.0\common\officeupdate" -ErrorAction SilentlyContinue).updatebranch
				if ($O365CurrentVer.Length -eq 0) {
					Write-Host "Office 365 (C2R) is not installed on this PC."
				} else {
					Write-Host "Office 365 (C2R) Current Version: "$O365CurrentVer
					switch ($O365CurrentCdn) {
						"http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60" {$O365CurrentCdn = "Monthly Channel"}
						"http://officecdn.microsoft.com/pr/7ffbc6bf-bc32-4f92-8982-f9dd17fd3114" {$O365CurrentCdn = "Semi-Annual Channel"}
						"http://officecdn.microsoft.com/pr/b8f9b850-328d-4355-9145-c59439a0c4cf" {$O365CurrentCdn = "Semi-Annual Channel (Targeted)"}
					}
					Write-Host "Office 365 Update Channel (Local Setting): "$O365CurrentCdn
					if ($O365CurrentPol.length -eq 0) {
						$O365CurrentPol = "None"
					} else {
						switch ($O365CurrentPol) {
							"Current" {$O365CurrentPol = "Monthly Channel"}
							"Deferred" {$O365CurrentPol = "Semi-Annual Channel"}
							"FirstReleaseDeferred" {$O365CurrentPol = "Semi-Annual Channel (Targeted)l"}
						}
					}
					Write-Host "Office 365 Update Channel (Policy Setting): "$O365CurrentPol
					Write-Host "`n"
				}
			}

			Function Wait-UpdateStop {
				param
				(
					[Parameter(Mandatory=$False)]
					[string]$Process
				)

				Function Get-SpecificProcess {
					Get-Process OfficeClickToRun -ErrorAction SilentlyContinue | Where-Object -Property Path -Like "*Microsoft Shared\ClickToRun\Updates\*"
				}

				$Timeout = 190 ## seconds
				Try {
					$timer = [Diagnostics.Stopwatch]::StartNew()
					while (($timer.Elapsed.TotalSeconds -lt $Timeout) -and (-not (Get-SpecificProcess))) {
						Start-Sleep -Seconds 2
						$totalSecs = [math]::Round($timer.Elapsed.TotalSeconds, 0)
						Write-Verbose -Message "Still waiting for action to complete after [$totalSecs] seconds..."
					}
					$timer.Stop()
					if ($timer.Elapsed.TotalSeconds -gt $Timeout) {
						Write-Host "Office update either failed or is already up to date"
					} else {
						Do {
							If (!(Get-SpecificProcess)) {
								   Write-Host "Waiting for $Process to Start"
								   Start-Sleep -Seconds 2
							} Else {
							   Write-Host "$Process has Started"
							   While (Get-SpecificProcess) {
										[String]$CPU = (Get-SpecificProcess).CPU
										If ($CPU.Length -gt 4) {$CPU = $CPU.substring(0,4)}
										Write-Host -NoNewLine "`rWaiting for $Process to stop. CPU time = $CPU"
										Start-Sleep -Seconds 5
							   }
							   Write-Host "`n`n$Process Stopped" ; $Status = 'Done'
							}
						} Until ($Status)
					}
				} Catch {
					Write-Error -Message $_.Exception.Message
				}
			}

			Get-Office365Version

			If (!($O365CurrentCdn -like "*monthlty*")) {
				Write-Host "Setting update channel to monthly"
				& "C:\Program Files\Common Files\Microsoft Shared\ClickToRun\OfficeC2RClient.exe" /changesetting Channel=Current
			}

			Write-Host "Updating Office, please wait 120 seconds to see further progress."
				& "C:\Program Files\Common Files\Microsoft Shared\ClickToRun\OfficeC2RClient.exe" /update user updatepromptuser=false forceappshutdown=true displaylevel=false
				Restart-Service -Name "ClickToRunSvc" -Force -ErrorAction SilentlyContinue
				Wait-UpdateStop OfficeClickToRun

				Write-Host "`n"

			Get-Office365Version
		}
	}
}

Function Update-PowershellModules {
	Set-ExecutionPolicy RemoteSigned -Scope Process -Force
	[Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls12
	$Providers = (Get-PackageProvider).Name
	If ($Providers -NotContains "Nuget") {
		Install-PackageProvider -Name NuGet -Force -ErrorAction SilentlyContinue
	}
	$Modules = Get-Module
	$ModulesToInstall = "PSReadline","PowerShellGet"
	$ModulesToInstall | ForEach-Object {
		$Mod = $_
		Remove-Module $Mod -Force -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
		Uninstall-Module $Mod -Force -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
		If ($Modules.Name -NotContains $Mod) {
			Write-Host "$Mod not found, installing."
			Install-Module -Name $Mod -Scope AllUsers -Force -AllowClobber -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
			Try {
				Import-Module -Name $Mod -Scope AllUsers -Force -ErrorAction Stop -WarningAction SilentlyContinue
			} Catch {
				Import-Module -Name $Mod -Force -WarningAction SilentlyContinue
			}
		}
		Clear-Variable -Name Mod -Force
	}
	Try {
		Update-Module -Scope AllUsers -Force -WarningAction SilentlyContinue
	} Catch {
		Update-Module -Force -WarningAction SilentlyContinue
	}
	Set-PSReadLineOption -PredictionSource History
	Get-Module | Select Name, Version, Description
}

Function Update-PWSH {
	Write-Host "Updating PWSH"
	If (!(Get-Command choco -ErrorAction SilentlyContinue)) {Install-Choco}
	Choco upgrade pwsh -y
}

Function Update-Windows {
	Write-Host "Install Windows Updates"
		Set-ExecutionPolicy Bypass -Scope Process -Force
		Enable-SSL
		Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Windows-Update/UpdateWindows.txt -UseBasicParsing | Invoke-Expression
	Write-Host "End of Install Windows Updates"
}

Function Update-WindowsApps {
	Write-Host "Updating Windows Apps"
		Start-Process ms-windows-store:
		Start-Sleep -Seconds 5
		(Get-WmiObject -Namespace "root\cimv2\mdm\dmmap" -Class "MDM_EnterpriseModernAppManagement_AppManagement01").UpdateScanMethod()
	Write-Host "Update Windows Apps initiated"
}

Function Update-WindowTitle ([String] $PassNumber) {
	Write-Host "Changing window title"
		$host.ui.RawUI.WindowTitle = "$SiteCode Provisioning | $env:computername | Pass $PassNumber | Please Wait"
}

If (Get-Module -Name ATGPS -ErrorAction SilentlyContinue){
	# List imported functions from ATGPS
	Write-Host `n====================================================
	Write-Host "The below functions are now loaded and ready to use:"
	Write-Host ====================================================

	Get-Command -Module ATGPS | Format-Wide -Column 3

	Write-Host ====================================================
	Write-Host "Type: 'Help <function name> -Detailed' for more info"
	Write-Host ====================================================
}
