Function Add-IEShortcut{
	param
	(
		[string]$Label,
		[string]$Url
	)

	$TargetFile = "C:\Program Files\Internet Explorer\iexplore.exe"
	$ShortcutFile = "$env:Public\Desktop\" + $Label + ".lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.Arguments = $Url
	$Shortcut.Save()
}

Function Add-WebShortcut{
	param
	(
		[string]$Label,
		[string]$Url
	)

	Write-Host "Adding a shortcut to $Label to the desktop"
	$Shell = New-Object -ComObject ("WScript.Shell")
	$URLFilePath = $env:Public + "\Desktop\" + $Label + ".url"
	$Favorite = $Shell.CreateShortcut($URLFilePath)
	$Favorite.TargetPath = $Url
	$Favorite.Save()
}

Function Connect-NetExtender {
	param
	(
		[Parameter(Mandatory=$False)]
		[string]$DC,

		[Parameter(Mandatory=$true)]
		[string]$VPNuri,

		[Parameter(Mandatory=$true)]
		[string]$VPNuser,

		[Parameter(Mandatory=$true)]
		[string]$VPNpassword,

		[Parameter(Mandatory=$true)]
		[string]$VPNdomain
	)

	If (([string]::IsNullOrWhiteSpace($DC)) -or (-not (Test-Connection -comp $DC -quiet))) {
		If (!(Test-Path -LiteralPath 'C:\Program Files (x86)\SonicWALL\SSL-VPN\NetExtender\NEClI.exe')) {
			Install-NetExtender
		}
		Write-host "Initiating VPN connection"
		echo y | & 'C:\Program Files (x86)\SonicWALL\SSL-VPN\NetExtender\NEClI.exe' connect -s $VPNuri -u $VPNuser -p $VPNpassword -d $VPNdomain
	}
<#
	.DESCRIPTION
		Initiates an SSLVPN connection to a site using Sonicwall NetExtender
	.PARAMETER DC
		(Optional) A domain controller whose connection to can be tested to see if the vpn connection is needed. Example -DC "tsdc"
	.PARAMETER VPNuri
		The connection URL and port. Example -VPNuri "vpn.ambitinsgroup.com:4433"
	.PARAMETER VPNuser
		The vpn enable user to be used. Example -VPNuser "vpnuser"
	.PARAMETER VPNpassword
		The vpn user's password to be used. Example -VPNpassword "s0m3Gr3@tPw"
	.PARAMETER VPNdomain
		The SSLVPN domain to be used, found in the sonicwall settings. Example -VPNdomain "LocalDomain"
	.EXAMPLE
		Connect-NetExtender -DC "TSDC" -VPNuri "vpn.ts.com:4433" -VPNuser "tsadmin" -VPNpassword "R@nD0m!" -VPNdomain "LocalDomain"
		This example connects to the client Test Site, if such a client were to exist.
#>
}

Function Connect-O365 {
	If ($PSVersionTable.PSEdition -like "Desktop") {
		Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
		Install-Module -Name ExchangeOnlineManagement -AllowClobber -Force
		Connect-ExchangeOnline -ShowProgress $true

		Write-Host -ForegroundColor Green -BackgroundColor DarkRed @"
		Be sure to disconnect the remote PowerShell session when you're finished.
		If you close the Windows PowerShell window without disconnecting the session,
		you could use up all the remote PowerShell sessions available to you,
		and you'll need to wait for the sessions to expire.
		To disconnect the remote PowerShell session, run the following command.

		Disconnect-ExchangeOnline
"@
	} Else {
		Write-Host -ForegroundColor Green -BackgroundColor DarkRed "Warning! You are using a CORE edition of Powershell. MFA will be unavailable."
		$UserCredential = Get-Credential
		$Session = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri https://outlook.office365.com/powershell-liveid/ -Credential $UserCredential -Authentication Basic -AllowRedirection
		Import-PSSession $Session
		
		Write-Host -ForegroundColor Green -BackgroundColor DarkRed @"
		Be sure to disconnect the remote PowerShell session when you're finished.
		If you close the Windows PowerShell window without disconnecting the session,
		you could use up all the remote PowerShell sessions available to you,
		and you'll need to wait for the sessions to expire.
		To disconnect the remote PowerShell session, run the following command.

		Get-PSSession | Remove-PSSession
"@
	}
	
<#
	.DESCRIPTION
		Initiates an Office 365 Exchange connection that is compatible with MFA.
		This is not compatible with Powershell Core.
		
	.LINK
		https://docs.microsoft.com/en-us/powershell/exchange/connect-to-exchange-online-powershell?view=exchange-ps
		
	.EXAMPLE
		Connect-O365
		Yup, that's it!
#>
}

Function Disable-ATGLocalExpiration {
	Write-Host "Set local ATGLocal account to never expire"
		Set-LocalUser -Name "ATGLocal" -PasswordNeverExpires $True
}

Function Disable-FastStartup {
	Write-Host "Disable Windows Fast Startup"
		REG ADD "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Power" /v HiberbootEnabled /t REG_DWORD /d "0" /f
		powercfg -h off
}

Function Disconnect-AllUsers {
<#
	.DESCRIPTION
		Logs off all users from a machine.
#>	
	(quser) -replace ">"," " -replace "\s+","," -replace "IDLE,TIME","IDLE TIME" -replace "LOGON,TIME","LOGON TIME" | ConvertFrom-Csv -Delimiter "," | foreach {
		logoff ($_.ID)
	}
}

Function Enable-SSL {
	Write-Host "Enabling SSL"
	[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
}

Function Expand-Terminal {
	mode con: cols=160 lines=120
}

Function Get-ADUserPassExpirations {
    <#
	.DESCRIPTION
		Retrieves a list of (enabled) Active Directory Users and shows their password expiration times.
	#>

	# check the name of the parent process.  If it's LogMeIn, we can't use the Out-GridView UI
	$parentProcessName = (Get-Process -Id ((Get-WmiObject Win32_Process -Filter "processid='$PID'").ParentProcessId)).Name

	# check to see whether Get-AdUser is available
	if (Get-Command ActiveDirectory\Get-AdUser -ErrorAction SilentlyContinue) {

		$adUserInfo = Get-ADUser -Filter {Enabled -eq $True -and PasswordNeverExpires -eq $False} `
		–Properties "DisplayName", "userPrincipalName", "msDS-UserPasswordExpiryTimeComputed" | `
		Select-Object -Property "Displayname","userPrincipalName",@{Name="ExpiryDate";Expression={[datetime]::FromFileTime($_."msDS-UserPasswordExpiryTimeComputed")}}

		# if the parent process of this powershell instance is not explorer.exe, output to PowerShell table.
		If ($parentProcessName -ne "explorer") {
			$adUserInfo | Format-Table -AutoSize
		} else { # otherwise, grid view UI
			$adUserInfo | Out-GridView -Title "ATG Powershell --> User Password Expirations"
		}

	} else { # cannot continue, Get-AdUser is not available
		Write-Host "`n [!] This command must be run on a system with Active Directory Powershell Modules (i.e. a domain controller)`n"
	}
}

Function Install-AppDefaults {
	Write-Host "Downloading App Defaults"
	New-Item -ItemType Directory -Force -Path C:\Ambitions\ITS247Agent
	(New-Object System.Net.WebClient).DownloadFile('https://download.ambitionsgroup.com/AppDefaults.xml', 'C:\Ambitions\AppDefaults.xml')
	Write-Host "Deploying App Defaults"
	Dism.exe /online /import-defaultappassociations:'C:\Ambitions\AppDefaults.xml'
}

Function Install-Choco {
	Write-Host "Installing Chocolatey"
	$progressPreference = 'silentlyContinue'
	Set-ExecutionPolicy Bypass -Scope Process -Force
	Enable-SSL
	Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Chocolatey/installchoco.txt -UseBasicParsing | Invoke-Expression
}

Function Install-ITS247Agent {
	$progressPreference = 'silentlyContinue'
	Set-ExecutionPolicy Bypass -Scope Process -Force
	Enable-SSL
	Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/ITS247Agent/Install_ITS247_Agent.txt -UseBasicParsing | Invoke-Expression
}

Function Install-NetExtender {
	Write-Host "Downloading & Installing NetExtender"
		If (!(Get-Command choco)) {Install-Choco}
		choco install sonicwall-sslvpn-netextender -y
}

Function Install-NiniteApps {
	If (-not (Test-Path 'C:\Ambitions\NinitePro.exe')) {Install-NinitePro}
	Write-Host "Install Ninite Apps, waiting for install to complete and logging the results."
		$NiniteCache = "\\adsaltoxl\data\Software\Ninite\NiniteDownloads"
		If(test-path $NiniteCache){
			& C:\Ambitions\NinitePro.exe /select 7-Zip Air Chrome 'Firefox ESR' Flash Greenshot 'Notepad++' 'Paint.NET' Reader Silverlight VLC /cachepath $NiniteCache /silent 'C:\Ambitions\NiniteReport.txt' | Wait-Process
		} ELSE {
			& C:\Ambitions\NinitePro.exe /select 7-Zip Air Chrome 'Firefox ESR' Flash Greenshot 'Notepad++' 'Paint.NET' Reader Silverlight VLC /nocache /silent 'C:\Ambitions\NiniteReport.txt' | Wait-Process
		}
	Write-Host "End of Install Ninite Apps"
}

Function Install-NinitePro {
	Write-Host "Downloading Ninite Installer"
	New-Item -ItemType Directory -Force -Path C:\Ambitions
	(New-Object System.Net.WebClient).DownloadFile('https://download.ambitionsgroup.com/NinitePro.exe', 'C:\Ambitions\NinitePro.exe')
	Write-Host "Schedule Ninite Updates"
	$Trigger = New-ScheduledTaskTrigger -AtStartup
	$User = "NT AUTHORITY\SYSTEM"
	$Action = New-ScheduledTaskAction -Execute "C:\Ambitions\NinitePro.exe" -Argument "/updateonly /nocache /silent C:\Ambitions\NiniteUpdates.log"
	Register-ScheduledTask -TaskName "Update Apps" -Trigger $Trigger -User $User -Action $Action -RunLevel Highest -Force
	Write-Host "End of Schedule Ninite Updates"
}

Function Install-O2016STD([String] $MSPURL){
	Write-Host "Downloading MS Office"
		Enable-SSL
		New-Item -ItemType Directory -Force -Path 'C:\Ambitions\O2016STD'
		(New-Object System.Net.WebClient).DownloadFile('http://download.ambitionsgroup.com/Software/O2016_STD_X64.exe', 'C:\Ambitions\O2016STD\O2016_STD_X64.exe')

	Write-Host "Downloading MS Office config files"
		$MSPfilename = $MSPURL.Substring($MSPURL.LastIndexOf("/") + 1)
		$MSPfilepath = 'C:\Ambitions\O2016STD\' + $MSPfilename
		(New-Object System.Net.WebClient).DownloadFile($MSPURL, $MSPfilepath)

	Write-Host "Installing Office"
		& 'C:\Ambitions\O2016STD\O2016_STD_X64.exe' -pth!nSong70 -oC:\Ambitions\O2016STD -y | Wait-Process
		& 'C:\Ambitions\O2016STD\setup.exe' /adminfile $MSPfilepath | Wait-Process

	Write-Host "Placing Shortcuts"
		$TargetFile = 'C:\Program Files\Microsoft Office\Office16\OUTLOOK.EXE'
		$ShortcutFile = "$env:Public\Desktop\Outlook.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		$TargetFile = 'C:\Program Files\Microsoft Office\Office16\EXCEL.EXE'
		$ShortcutFile = "$env:Public\Desktop\Excel.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		$TargetFile = 'C:\Program Files\Microsoft Office\Office16\WINWORD.EXE'
		$ShortcutFile = "$env:Public\Desktop\Word.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()
}

Function Install-O365([String] $SiteCode = "Generic"){
	Write-Host "Downloading MS Office"
		Enable-SSL
		New-Item -ItemType Directory -Force -Path "C:\Ambitions\O365"
		(New-Object System.Net.WebClient).DownloadFile('https://download.ambitionsgroup.com/O365/setup.exe', 'C:\Ambitions\O365\setup.exe')
	Write-Host "Downloading MS Office config files"
		$O365ConfigSource = "https://download.ambitionsgroup.com/Sites/" + $SiteCode + "/" + $SiteCode + "_O365_Config.xml"
		$O365ConfigDest = "C:\Ambitions\O365\" + $SiteCode + "_O365_Config.xml"
		(New-Object System.Net.WebClient).DownloadFile($O365ConfigSource, $O365ConfigDest)
	Write-Host "Installing Office"
		& C:\Ambitions\O365\setup.exe /configure $O365ConfigDest | Wait-Process
	Write-Host "Placing Shortcuts"
		$TargetFile = "C:\Program Files\Microsoft Office\root\Office16\OUTLOOK.EXE"
		$ShortcutFile = "$env:Public\Desktop\Outlook.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		$TargetFile = "C:\Program Files\Microsoft Office\root\Office16\EXCEL.EXE"
		$ShortcutFile = "$env:Public\Desktop\Excel.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		$TargetFile = "C:\Program Files\Microsoft Office\root\Office16\WINWORD.EXE"
		$ShortcutFile = "$env:Public\Desktop\Word.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()
}

Function Install-ProofPointExchangeConnectors {
<#
	.DESCRIPTION
		Installs the proofpoint inbound and outbound connectors in exchange online, as well as spam bypass for emails coming from exchange.
#>
	If (Get-Command Get-Mailbox -ErrorAction SilentlyContinue){
		$ExceptIfSenderIpRanges = @"
		148.163.159.0/24
		148.163.158.0/24
		148.163.157.0/24
		148.163.156.0/24
		148.163.155.0/24
		148.163.154.0/24
		148.163.153.0/24
		148.163.151.0/24
		148.163.150.0/24
		148.163.149.0/24
		148.163.148.0/24
		148.163.147.0/24
		148.163.146.0/24
		148.163.145.0/24
		148.163.143.0/24
		148.163.142.0/24
		148.163.141.0/24
		148.163.140.0/24
		148.163.139.0/24
		148.163.138.0/24
		148.163.137.0/24
		148.163.135.0/24
		148.163.134.0/24
		148.163.133.0/24
		148.163.132.0/24
		148.163.131.0/24
		148.163.130.0/24
		148.163.129.0/24
		52.54.85.198
		52.55.243.18
		34.192.199.2
		67.231.156.0/24
		67.231.155.0/24
		67.231.154.0/24
		67.231.153.0/24
		67.231.152.0/24
		67.231.148.0/24
		67.231.147.0/24
		67.231.146.0/24
		67.231.145.0/24
		67.231.144.0/24
		148.163.152.0/24
		148.163.144.0/24
		148.163.136.0/24
		148.163.128.0/24
		67.231.152.0/24
		67.231.153.0/24
		67.231.154.0/24
		67.231.155.0/24
		67.231.156.0/24
		67.231.144.0/24
		67.231.145.0/24
		67.231.146.0/24
		67.231.147.0/24
		67.231.148.0/24
		67.231.149.0/24
		148.163.128.0/24
		148.163.129.0/24
		148.163.130.0/24
		148.163.131.0/24
		148.163.132.0/24
		148.163.133.0/24
		148.163.134.0/24
		148.163.135.0/24
		148.163.136.0/24
		148.163.137.0/24
		148.163.138.0/24
		148.163.139.0/24
		148.163.140.0/24
		148.163.141.0/24
		148.163.142.0/24
		148.163.143.0/24
		148.163.144.0/24
		148.163.145.0/24
		148.163.146.0/24
		148.163.147.0/24
		148.163.148.0/24
		148.163.149.0/24
		148.163.150.0/24
		148.163.151.0/24
		148.163.152.0/24
		148.163.153.0/24
		148.163.154.0/24
		148.163.155.0/24
		148.163.156.0/24
		148.163.157.0/24
		148.163.158.0/24
		148.163.159.0/24
		34.192.199.2
		52.55.243.18
		52.54.85.198
"@

		Function Install-ProofPointInbound {
			New-InboundConnector -Name “Inbound from ProofPoint” -Comment “Only accept email from ProofPoint transport addresses” -Enabled $false  -SenderDomains * -RestrictDomainsToIPAddresses $true -RequireTls $true -SenderIPAddresses $ExceptIfSenderIpRanges
		}

		Function Install-ProofPointOutbound {
			New-OutboundConnector -Name “Outbound to ProofPoint” -Comment “Send all external outbound email through ProofPoint SmartHost” -Enabled $true -RecipientDomains * -SmartHosts outbound-us1.ppe-hosted.com -TlsSettings EncryptionOnly -UseMXRecord $false
		}

		If (Get-InboundConnector) {
			$Readhost = Read-Host "Warning, an inbound connector already exists.`nAre you sure you want to install the ProofPoint connector which may conflict?`n( y / n ) " 
			Switch ($ReadHost) 
			{ 
				Y { Write-Host "Installing the Proofpoint Inbound Connector.";Install-ProofPointInbound } 
				N { break } 
				Default { "You didn't enter the a correct response" }
			} 
		} else {
			Write-Host "Installing the Proofpoint Inbound Connector."
			Install-ProofPointInbound
		}
		
		If (Get-OutboundConnector) {
			$Readhost = Read-Host "Warning, an outbound connector already exists.`nAre you sure you want to install the ProofPoint connector which may conflict? ( y / n ) "
			Switch ($ReadHost) 
			{ 
				Y { Write-Host "Installing the Proofpoint Outbound Connector.";Install-ProofPointOutbound } 
				N { break } 
				Default { "You didn't enter the a correct response" }
			} 
		} Else {
			Write-Host "Installing the Proofpoint Outbound Connector."
			Install-ProofPointOutbound
		}
		
		Set-HostedConnectionFilterPolicy “Default” -IPAllowList $ExceptIfSenderIpRanges
	} Else {
		Write-Host "You are not connected to an exchange server. Try the command 'Connect-O365'."
	}	
}

Function Invoke-Win10Decrap {
	Write-Host "Windows 10 Decrapifier"
	$progressPreference = 'silentlyContinue'
	Set-ExecutionPolicy Bypass -Scope Process -Force
	Enable-SSL
	Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Win-10-DeCrapifier/Windows10Decrapifier.txt -UseBasicParsing | Invoke-Expression
}

Function Join-Domain {
		param
	(
		[Parameter(Mandatory=$true)]
		[string]$Domain,
		[Parameter(Mandatory=$true)]
		[string]$Username,
		[Parameter(Mandatory=$true)]
		$Password
	)
	Write-Host "Join Domain"
	$Password = $Password | ConvertTo-SecureString -asPlainText -Force
	$Username = $Domain + "\" + $Username
	$credential = New-Object System.Management.Automation.PSCredential($Username,$Password)
	Add-Computer -DomainName $Domain -Credential $credential
}

Function Remove-ITS247InstallFolder {
	Write-Host "Cleaning up and Restarting Computer"
	PowerShell.exe -NoProfile -ExecutionPolicy Bypass -Command "If (Test-Path C:\Ambitions\ITS247Agent){Remove-Item -LiteralPath 'C:\Ambitions\ITS247Agent' -Force -Recurse};Restart-Computer -Force"
	Stop-transcript
	Restart-Computer -Force
}

Function Rename-ClientComputer {
	Write-Host "Rename Computer"
		$title = 'Rename Computer'
		$msg = 'Enter the client shortcode (e.g. AAIHB) or Dept code'
		$SerialNumber = (Get-WmiObject win32_bios).SerialNumber
		#Message box prompts onscreen for input
		[void][Reflection.Assembly]::LoadWithPartialName('Microsoft.VisualBasic')
		$ClientCode = [Microsoft.VisualBasic.Interaction]::InputBox($msg, $title)
		Rename-Computer ($ClientCode + "-" + $SerialNumber) -Force
	Write-Host "End of Rename Computer"
}

Function Repair-Windows {
	$StartTime = (Get-Date)
	(Get-Date).DateTime | Out-Host
	Write-Host Repair-Volume -DriveLetter $Env:SystemDrive.SubString(0,1) -Scan
	$chdksk = Repair-Volume -DriveLetter $Env:SystemDrive.SubString(0,1) -Scan
	If ($chdksk -ne "NoErrorsFound") {Repair-Volume -DriveLetter $Env:SystemDrive.SubString(0,1) -SpotFix}
	Write-Host Dism /Online /Cleanup-Image /StartComponentCleanup
	Dism /Online /Cleanup-Image /StartComponentCleanup
	Write-Host ...
	(Get-Date).DateTime | Out-Host
	Write-Host Dism /Online /Cleanup-Image /RestoreHealth
	Dism /Online /Cleanup-Image /RestoreHealth
	Write-Host ...
	(Get-Date).DateTime | Out-Host
	Write-Host SFC /scannow
	SFC /scannow
	(Get-Date).DateTime | Out-Host
	$EndTime = (Get-Date) - $StartTime
	Write-Host "This process took:"
	$EndTime | FT | Out-Host
	Write-Host "Run this function repeately until no errors show up. If this fails after 3 tries, upgrade or reinstall windows"
}

Function Set-AutoLogon ([String] $SiteCode) {
	Write-Host "Set autologon"
		#Registry path declaration
		$RegPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
		[String]$DefaultUsername = 'ATGLocal'
		[String]$DefaultPassword = $SiteCode + 'T3mpP@ss'
		#setting registry values
		Set-ItemProperty $RegPath "AutoAdminLogon" -Value "1" -type String
		Set-ItemProperty $RegPath "DefaultUsername" -Value $DefaultUsername -type String
		Set-ItemProperty $RegPath "DefaultPassword" -Value $DefaultPassword -type String
		Set-ItemProperty $RegPath "AutoLogonCount" -Value "1" -type DWord
	Write-Host "End of Set autologon"
}

Function Set-DailyReboot {
	Write-Host "Schedule Daily Restart"
		$Action = New-ScheduledTaskAction -Execute 'shutdown.exe' -Argument '-f -r -t 0'
		$Trigger =New-ScheduledTaskTrigger -Daily -At 3am
		$Idle = New-ScheduledTaskSettingsSet -RunOnlyIfIdle -IdleDuration 00:30:00 -IdleWaitTimeout 02:00:00
		$User = "NT AUTHORITY\SYSTEM"
		Register-ScheduledTask -Action $action -Trigger $trigger -User $User -Settings $Idle -TaskName "Daily Restart" -Description "Daily restart"
}

Function Set-MountainTime {
	Write-Host "Setting local time zone to Mountain Time"
	Set-TimeZone -Name "Mountain Standard Time"
	net start W32Time
	W32tm /resync /force
}

Function Set-NumLock {
	Write-Host "Setting Numlock on keyboard as default"
	Set-ItemProperty -Path 'Registry::HKU\.DEFAULT\Control Panel\Keyboard' -Name "InitialKeyboardIndicators" -Value "2" -Force -PassThru
}

Function Set-RunOnceScript {
	param
	(
		[string]$Label,
		[string]$Script
	)

	$RunOnceValue = 'PowerShell.exe -ExecutionPolicy Bypass -File "' + $Script + '"'
	Write-Host "Install After Reboot"
	Set-ItemProperty 'HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce' -Name $Label -Value $RunOnceValue
}

Function Start-PPKGLog ([String] $LogLabel) {
	Write-Host "Making a log file for debugging"
		$LogPath = "C:\Ambitions\" + $SiteCode + "-" + $LogLabel + ".log"
		Start-Transcript -path $LogPath -Force -Append
}

Function Update-DattoAgent {
	Enable-SSL
	$progressPreference = 'silentlyContinue'
	iwr https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Datto-Agent-Update/DattoAgentUpdate.txt -usebasicparsing | iex
}

Function Update-DellPackages {
	Write-Host "Dell Updates"
		$Manufact = (Get-CimInstance -Class Win32_ComputerSystem).Manufacturer
		if( $Manufact -like "*Dell*")
		{
			Enable-SSL
			Set-ExecutionPolicy Bypass -Scope Process -Force; Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Dell-Command-Update/DCU_AUTO.txt -UseBasicParsing | Invoke-Expression
		} else { Write-Host This is not a Dell Computer}
	Write-Host "End of Dell Updates"
}

Function Update-Edge {
	Write-Host "Updating Microsoft Edge"
	If (!(Get-Command choco)) {Install-Choco}
	If (Get-Process MicrosoftEdge -ErrorAction SilentlyContinue) {Get-Process MicrosoftEdge | Stop-Process -Force}
	Choco upgrade microsoft-edge -y
}

Function Update-ITS247Agent {
	$DisplayVersion = (Get-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\SAAZOD).DisplayVersion
	$TYPE = (Get-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\SAAZOD).TYPE
	$AvailableVersion = (Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/ITS247Agent/DPMAVersion.txt -UseBasicParsing)

	if(($DisplayVersion -ne $AvailableVersion) -and ($TYPE -eq "DPMA")) {
	 WRITE-HOST "Updating Agent from $DisplayVersion to $AvailableVersion"
		 $SaveFolder = 'C:\Ambitions'
		 New-Item -ItemType Directory -Force -Path $SaveFolder
		 $PatchPath = $SaveFolder + '\DPMAPatch' + $AvailableVersion + '.exe'
		 (New-Object System.Net.WebClient).DownloadFile('http://update.itsupport247.net/agtupdt/DPMAPatch.exe', $PatchPath)
		 & $PatchPath | Wait-Process
		 $DisplayVersion = (Get-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\SAAZOD).DisplayVersion
	 WRITE-HOST "Agent is now version $DisplayVersion"
	}
<#
	.DESCRIPTION
		Updates the Continuum ITS247 Desktop agent to the latest available. No parameters are needed.
#>
}

Function Update-NiniteApps {
	<#
	.DESCRIPTION
		Uses NinitePro to immediately update all applications it is cabable of updating. The log will be at C:\Ambitions\NiniteReport.txt
	#>
    If (-not (Test-Path 'C:\Ambitions\NinitePro.exe')) {Install-NinitePro}
    Write-Host "Install Ninite Apps, waiting for install to complete and logging the results."
        $NiniteCache = "\\adsaltoxl\data\Software\Ninite\NiniteDownloads"
        If(test-path $NiniteCache){
            & C:\Ambitions\NinitePro.exe /select 7-Zip Air Chrome 'Firefox ESR' Flash Greenshot 'Notepad++' 'Paint.NET' Reader Silverlight VLC /cachepath $NiniteCache /silent 'C:\Ambitions\NiniteReport.txt' | Wait-Process
        } ELSE {
            & C:\Ambitions\NinitePro.exe /updateonly /nocache /silent 'C:\Ambitions\NiniteReport.txt' | Wait-Process
        }
    Write-Host "End of Install Ninite Apps"
}

Function Update-PWSH {
	Write-Host "Updating PWSH"
	If (!(Get-Command choco)) {Install-Choco}
	Choco upgrade pwsh -y
}

Function Update-Windows {
	Write-Host "Install Windows Updates"
		Set-ExecutionPolicy Bypass -Scope Process -Force
		Enable-SSL
		Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Windows-Update/UpdateWindows.txt -UseBasicParsing | Invoke-Expression
	Write-Host "End of Install Windows Updates"
}

Function Update-WindowsApps {
	Write-Host "Updating Windows Apps"
		Start-Process ms-windows-store:
		Start-Sleep -Seconds 5
		(Get-WmiObject -Namespace "root\cimv2\mdm\dmmap" -Class "MDM_EnterpriseModernAppManagement_AppManagement01").UpdateScanMethod()
	Write-Host "Update Windows Apps initiated"
}

Function Update-WindowTitle ([String] $PassNumber) {
	Write-Host "Changing window title"
		$host.ui.RawUI.WindowTitle = "$SiteCode Provisioning | $env:computername | Pass $PassNumber | Please Wait"
}

If (Get-Module -Name ATGPS -ErrorAction SilentlyContinue){
	# List imported functions from ATGPS
	Write-Host `n====================================================
	Write-Host "The below functions are now loaded and ready to use:"
	Write-Host ====================================================

	Get-Command -Module ATGPS | Format-Wide -Column 3

	Write-Host ====================================================
	Write-Host "Type: 'Help <function name> -Detailed' for more info"
	Write-Host ====================================================
}
