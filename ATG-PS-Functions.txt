Function Add-ChromeShortcut{
	#Requires -RunAsAdministrator

	param
	(
		[Parameter(Mandatory=$true)]
		[string]$Label,

		[Parameter(Mandatory=$true)]
		[string]$Url
	)

	If (Test-Path -Path 'C:\Program Files\Google\Chrome\Application\chrome.exe') {
		$TargetFile = "C:\Program Files\Google\Chrome\Application\chrome.exe"
	} ElseIf (Test-Path -Path 'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe') {
		$TargetFile = "C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"
	} Else {
		Write-Host "Google Chrome was not found. Please install manually or with Chocolatey:"
		Write-Host "   Install-Choco"
		Write-Host "   choco install GoogleChrome"
	}

	If ($TargetFile) {
		$ShortcutFile = "$env:Public\Desktop\" + $Label + ".lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Arguments = $Url
		$Shortcut.Save()
	}
	<#
    .DESCRIPTION
        Creates a Google Chrome Shortcut on the "All Users" Desktop.
		If Google Chrome is not found, prompts to install the program using ATG-PS scripts + Chocolately.
    .PARAMETER Label
        The file name of the shortcut; ".lnk" is automatically appended.
    .PARAMETER Url
        The full URL that the shortcut intends to open: "https://www.google.com/"
    .EXAMPLE
        Add-ChromeShortcut -Label "Github ATG-PS" -Url "https://github.com/AmbitionsTechnologyGroup/ATG-PS-Functions/"
	#>
}

Function Add-FileFolderShortcut {

	param
	(
		[Parameter(Mandatory=$true)]
		[string]$SourceLnk,

		[Parameter(Mandatory=$true)]
		[string]$DestinationPath
	)

	$WshShell = New-Object -comObject WScript.Shell
	$Shortcut = $WshShell.CreateShortcut($SourceLnk)
	$Shortcut.TargetPath = $DestinationPath
	$Shortcut.Save()

	<#
	.DESCRIPTION
		Creates a shortcut to a file or folder.
	.PARAMETER SourceLnk
		The file name of the shortcut. Must end with ".lnk"
	.PARAMETER DestinationPath
		What the shortcut is pointing to. "C:\Ambitions\RyanIsAwesome.txt"
	.EXAMPLE
		Add-FileFolderShortcut "$env:Public\Desktop\Ambitions Folder.lnk" "C:\Ambitions"
		This example puts a shortcut on the desktop called "Ambitions Folder" and points to C:\Ambitions.
	#>

}

Function Add-IEShortcut {
	param
	(
		[Parameter(Mandatory=$true)]
		[string]$Label,

		[Parameter(Mandatory=$true)]
		[string]$Url
	)

	$TargetFile = "C:\Program Files\Internet Explorer\iexplore.exe"
	$ShortcutFile = "$env:Public\Desktop\" + $Label + ".lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.Arguments = $Url
	$Shortcut.Save()

	<#
    .DESCRIPTION
        Creates an Internet Explorer Shortcut on the "All Users" Desktop.
    .PARAMETER Label
        The file name of the shortcut; ".lnk" is automatically appended.
    .PARAMETER Url
        The full URL that the shortcut intends to open: "https://www.google.com/"
    .EXAMPLE
        Add-ChromeShortcut -Label "Github ATG-PS" -Url "https://github.com/AmbitionsTechnologyGroup/ATG-PS-Functions/"
	#>

}

Function Add-WebShortcut{
	param
	(
		[string]$Label,
		[string]$Url
	)

	Write-Host "Adding a shortcut to $Label to the desktop"
	$Shell = New-Object -ComObject ("WScript.Shell")
	$URLFilePath = $env:Public + "\Desktop\" + $Label + ".url"
	$Favorite = $Shell.CreateShortcut($URLFilePath)
	$Favorite.TargetPath = $Url
	$Favorite.Save()
}

Function Backup-LastUser {
	$RegKey = "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI"
	$RegFile = "C:\Ambitions\LastLoggedOnUser.reg"
	Write-Host "Backuping up last logged on user"
	reg export $RegKey $RegFile /y
	Write-Host "Trimming export"
	(Get-Content $RegFile)[0..10] | Out-File -FilePath $RegFile -Force
	$User = (Select-String -Path $RegFile -Pattern '"LastLoggedOnUser"' -SimpleMatch).Line
	Write-Host "$User has been backed up to $RegFile"
	Write-Host "`nTry the command Restore-LastUser"
<#
	.DESCRIPTION
		Backup-LastUser affects the user listed on the Windows Logon screen. If Sally is the last one that logged in, and she's use to just turning on her computer and entering her password because she's always the last one that used the computer, it'll really mess her up if you log in to fix something. Then she'll be entering her password on the admin account without ever looking to see that she needs to switch user back to herself.
		Use the command "Backup-LastUser". This saves Sally as a registry key.
		You login, do your stuff, then reboot or log out.
		Use the command "Restore-LastUser". This will change the default user at the login screen from "ATGAdmin" back to "Sally" or whatever user was backed up.
	.EXAMPLE
		Backup-LastUser
			Backuping up last logged on user
			The operation completed successfully.
			Trimming export
			"LastLoggedOnUser"=".\\Sally" has been backed up to C:\Ambitions\LastLoggedOnUser.reg
			Try the command Restore-LastUser
#>
}

Function Connect-NetExtender {
	param
	(
		[Parameter(Mandatory=$False)]
		[string]$DC,

		[Parameter(Mandatory=$true)]
		[string]$VPNuri,

		[Parameter(Mandatory=$true)]
		[string]$VPNuser,

		[Parameter(Mandatory=$true)]
		[string]$VPNpassword,

		[Parameter(Mandatory=$true)]
		[string]$VPNdomain
	)

	If (([string]::IsNullOrWhiteSpace($DC)) -or (-not (Test-Connection -comp $DC -quiet))) {
		If (!(Test-Path -LiteralPath 'C:\Program Files (x86)\SonicWALL\SSL-VPN\NetExtender\NEClI.exe')) {
			Install-NetExtender
		}
		Write-host "Initiating VPN connection"
		echo y | & 'C:\Program Files (x86)\SonicWALL\SSL-VPN\NetExtender\NEClI.exe' connect -s $VPNuri -u $VPNuser -p $VPNpassword -d $VPNdomain
	}
<#
	.DESCRIPTION
		Initiates an SSLVPN connection to a site using Sonicwall NetExtender
	.PARAMETER DC
		(Optional) A domain controller whose connection to can be tested to see if the vpn connection is needed. Example -DC "tsdc"
	.PARAMETER VPNuri
		The connection URL and port. Example -VPNuri "vpn.ambitinsgroup.com:4433"
	.PARAMETER VPNuser
		The vpn enable user to be used. Example -VPNuser "vpnuser"
	.PARAMETER VPNpassword
		The vpn user's password to be used. Example -VPNpassword "s0m3Gr3@tPw"
	.PARAMETER VPNdomain
		The SSLVPN domain to be used, found in the sonicwall settings. Example -VPNdomain "LocalDomain"
	.EXAMPLE
		Connect-NetExtender -DC "TSDC" -VPNuri "vpn.ts.com:4433" -VPNuser "tsadmin" -VPNpassword "R@nD0m!" -VPNdomain "LocalDomain"
		This example connects to the client Test Site, if such a client were to exist.
#>
}

Function Connect-O365Exchange {
	If ($PSVersionTable.PSEdition -like "Desktop") {
		If (-not (Get-Command Connect-ExchangeOnline -ErrorAction SilentlyContinue)) {
			Write-Host "Installing the Exchange Online Management module"
			Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
			Install-Module -Name ExchangeOnlineManagement -AllowClobber -Force
			$ModVer = (Get-Command Connect-ExchangeOnline).Version
			If ($ModVer) {
				Write-Host "Exchange Online Management module version $ModVer has been installed."
			} Else {
				Write-Host "Exchange Online Management module failed to install."
				Break
			}
		} Else {
			$Readhost = 'N'
			$Readhost = Read-Host "Do you want to check for module updates? This should be done periodically. `n(y/N)"
			Switch ($ReadHost)
			{
				Y {
					$ModVer = (Get-Command Connect-ExchangeOnline).Version
					$AvailableModVer = (Find-Module ExchangeOnlineManagement -Repository PSGallery).Version
					If ($ModVer -ne $AvailableModVer) {
						Write-host "ExchangeOnlineManagement has an update from $ModVer to $AvailableModVer.`nInstalling the update."
						Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
						Install-Module -Name ExchangeOnlineManagement -AllowClobber -Force
					} Else {
						Write-host "ExchangeOnlineManagement is already up to date at version $AvailableModVer."
					}
				}
				N { Write-Host "Skipping update check." }
				Default { Write-Host "Skipping update check." }
			}
		}
		Connect-ExchangeOnline -ShowProgress $true

		Write-Host -ForegroundColor Green -BackgroundColor DarkRed @"
		Be sure to disconnect the remote PowerShell session when you're finished.
		If you close the Windows PowerShell window without disconnecting the session,
		you could use up all the remote PowerShell sessions available to you,
		and you'll need to wait for the sessions to expire.
		To disconnect the remote PowerShell session, run the following command.

		Disconnect-ExchangeOnline
"@
	} Else {
		Write-Host -ForegroundColor Green -BackgroundColor DarkRed "Warning! You are using a CORE edition of Powershell. MFA will be unavailable."
		$UserCredential = Get-Credential
		$Session = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri https://outlook.office365.com/powershell-liveid/ -Credential $UserCredential -Authentication Basic -AllowRedirection
		Import-PSSession $Session

		Write-Host -ForegroundColor Green -BackgroundColor DarkRed @"
		Be sure to disconnect the remote PowerShell session when you're finished.
		If you close the Windows PowerShell window without disconnecting the session,
		you could use up all the remote PowerShell sessions available to you,
		and you'll need to wait for the sessions to expire.
		To disconnect the remote PowerShell session, run the following command.

		Get-PSSession | Remove-PSSession
"@
	}

<#
	.DESCRIPTION
		Initiates an Office 365 Exchange connection that is compatible with MFA.
		This is not compatible with Powershell Core.

	.LINK
		https://docs.microsoft.com/en-us/powershell/exchange/connect-to-exchange-online-powershell?view=exchange-ps

	.EXAMPLE
		Connect-O365
		Yup, that's it!
#>
}

Function Connect-Wifi {
	param
		(
			[Parameter(Mandatory=$False)]
			[string]$NetworkSSID,

			[Parameter(Mandatory=$true)]
			[string]$NetworkPassword,

			[ValidateSet('WEP','WPA','WPA2','WPA2PSK')]
			[Parameter(Mandatory=$False)]
			[string]$Authentication = 'WPA2PSK',

			[ValidateSet('AES','TKIP')]
			[Parameter(Mandatory=$False)]
			[string]$Encryption = 'AES'
		)

	# Create the WiFi profile, set the profile to auto connect
	$WirelessProfile = @'
<WLANProfile xmlns="http://www.microsoft.com/networking/WLAN/profile/v1">
	<name>{0}</name>
	<SSIDConfig>
		<SSID>
			<name>{0}</name>
		</SSID>
	</SSIDConfig>
	<connectionType>ESS</connectionType>
	<connectionMode>auto</connectionMode>
	<MSM>
		<security>
			<authEncryption>
				<authentication>{2}</authentication>
				<encryption>{3}</encryption>
				<useOneX>false</useOneX>
			</authEncryption>
			<sharedKey>
				<keyType>passPhrase</keyType>
				<protected>false</protected>
				<keyMaterial>{1}</keyMaterial>
			</sharedKey>
		</security>
	</MSM>
</WLANProfile>
'@ -f $NetworkSSID, $NetworkPassword, $Authentication, $Encryption

	# Create the XML file locally
	$random = Get-Random -Minimum 1111 -Maximum 99999999
	$tempProfileXML = "$env:TEMP\tempProfile$random.xml"
	$WirelessProfile | Out-File $tempProfileXML

	# Add the WiFi profile and connect
	Start-Process netsh ('wlan add profile filename={0}' -f $tempProfileXML)

	# Connect to the WiFi network - only if you need to
	$WifiNetworks = (netsh wlan show network)
	$NetworkSSIDSearch = '*' + $NetworkSSID + '*'
	If ($WifiNetworks -like $NetworkSSIDSearch) {
		Try {
			Write-Host "Found SSID: $NetworkSSID `nAttempting to connect"
			Start-Process netsh ('wlan connect name="{0}"' -f $NetworkSSID)
			Start-Sleep 5
			netsh interface show interface
		}
		Catch {
			Remove-Item -Force $tempProfileXML
		}
	} Else {
		Write-Host "Did not find SSID: $NetworkSSID `nConnection profile stored for later use."
	}
	Remove-Item -Force $tempProfileXML
}

Function Disable-ATGLocalExpiration {
	Write-Host "Set local ATGLocal account to never expire"
		Set-LocalUser -Name "ATGLocal" -PasswordNeverExpires $True
}

Function Disable-FastStartup {
	Write-Host "Disable Windows Fast Startup"
		REG ADD "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Power" /v HiberbootEnabled /t REG_DWORD /d "0" /f
		powercfg -h off
}

Function Disable-Sleep {
<#
.Synopsis
   Function to suspend your current Power Plan settings when running a PowerShell script.
.DESCRIPTION
   Function to suspend your current Power Plan settings when running a PowerShell script.
   Scenario: When downloading files using Robocopy from PowerShell you don't want your
   laptop to go into sleep mode.
.EXAMPLE
   Disable-Sleep
   Run mylongrunningscript with Display idle timeout prevented and verbose messages
#>

	If (!(Test-Path "C:\ProgramData\chocolatey\lib\dontsleep.portable\tools\DontSleep_x64_p.exe")) {
		If (!(Get-Command choco -ErrorAction SilentlyContinue)) {Install-Choco}
		choco install dontsleep.portable -y
	}
	& C:\ProgramData\chocolatey\lib\dontsleep.portable\tools\DontSleep_x64_p.exe -bg please_sleep_mode=0 enable=1
}

Function Disconnect-AllUsers {
<#
	.DESCRIPTION
		Logs off all users from a machine.
#>
	(quser) -replace ">"," " -replace "\s+","," -replace "IDLE,TIME","IDLE TIME" -replace "LOGON,TIME","LOGON TIME" | ConvertFrom-Csv -Delimiter "," | foreach {
		logoff ($_.ID)
	}
}

Function Disconnect-NetExtender {

	If (([string]::IsNullOrWhiteSpace($DC)) -or (-not (Test-Connection -comp $DC -quiet))) {
		If (!(Test-Path -LiteralPath 'C:\Program Files (x86)\SonicWALL\SSL-VPN\NetExtender\NEClI.exe')) {
			Write-Host "This command only works if you have Sonicwall NetExtender installed."
		}
		Write-host "Initiating VPN disconnection"
		& 'C:\Program Files (x86)\SonicWALL\SSL-VPN\NetExtender\NEClI.exe' disconnect
		& 'C:\Program Files (x86)\SonicWALL\SSL-VPN\NetExtender\NEClI.exe' disconnect
	}
<#
	.DESCRIPTION
		Disconnects an existing SSLVPN connection to a site using Sonicwall NetExtender
	.EXAMPLE
		Disconnect-NetExtender
		This example disconnects from the VPN session.
#>
}

Function Enable-O365AuditLog {
<#
	.DESCRIPTION
		Sets auditig on all mailboxes in the organization as well as sets the default setting.

	.LINK
		https://docs.microsoft.com/en-us/microsoft-365/compliance/enable-mailbox-auditing

	.LINK
		https://support.microsoft.com/en-us/help/4026501/office-auditing-in-office-365-for-admins
#>
	If (Get-Command Get-Mailbox -ErrorAction SilentlyContinue){
		Write-Host "Enabling Auditing for all existing mailboxes"
		Get-Mailbox -ResultSize Unlimited -Filter {RecipientTypeDetails -eq "UserMailbox"} | Set-Mailbox -AuditEnabled $true -Verbose
		Write-Host "Enabling Auditing for the organization as a whole"
		Set-OrganizationConfig -AuditDisabled $False
		Write-Host "Checking the orginazation config. If auditing is enabled, this setting should show as 'False'"
		Get-OrganizationConfig | Format-List AuditDisabled
	} Else {
		Write-Host "You are not connected to an exchange server. Try the command 'Connect-O365Exchange'"
	}
}

Function Enable-Sleep {
	If (Get-Process -Name "DontSleep_x64_p") {
		Write-Host "Resuming power management plan"
		Stop-Process -Name "DontSleep_x64_p" -Force
	} Else {
		Write-Host "Disable-Sleep wasn't running. Did you run 'Disable-Sleep'?"
	}
}

Function Enable-SSL {
	Write-Host "Enabling SSL"
	try {
	# Set TLS 1.2 (3072), then TLS 1.1 (768), then TLS 1.0 (192)
	# Use integers because the enumeration values for TLS 1.2 and TLS 1.1 won't
	# exist in .NET 4.0, even though they are addressable if .NET 4.5+ is
	# installed (.NET 4.5 is an in-place upgrade).
	[System.Net.ServicePointManager]::SecurityProtocol = 3072 -bor 768 -bor 192
	} catch {
	Write-Output 'Unable to set PowerShell to use TLS 1.2 and TLS 1.1 due to old .NET Framework installed. If you see underlying connection closed or trust errors, you may need to upgrade to .NET Framework 4.5+ and PowerShell v3+.'
	}
}

Function Expand-Terminal {
	mode con: cols=160 lines=120
}

Function Export-LDAPSCertificate {
    <#
	.DESCRIPTION
		If the server responds to requests on the LDAPS port 636, the function will attempt to isolate the Certificate in use and export it to C:\Ambitions\LDAPScerExport.cer
	#>
	If (Test-NetConnection -ComputerName localhost -Port 636 -InformationLevel Quiet) {
		$Cert = (Get-ChildItem -Path Cert:\LocalMachine -Recurse | Where-Object {$_.NotAfter -Gt (Get-Date) -and $_.Subject -like "*$env:computername.$env:userdnsdomain*" -and $_.NotAfter -eq ($_.NotBefore).AddYears(1)})
		$Cert | Select-Object Subject, NotBefore, NotAfter | Format-List
		$Path = "C:\Ambitions\LDAPScerExport.cer"
		Write-Host "Exporting current likely LDAPS Certificate to $Path"
		$Cert | Export-Certificate -Type cer -FilePath C:\Ambitions\LDAPScerExport.cer -Force | Out-Null
	} Else {
		Write-Warning "This computer does not appear to be serving LDAPS requests."
		Break
	}
}

Function Get-ADUserPassExpirations {
    <#
	.DESCRIPTION
		Retrieves a list of (enabled) Active Directory Users and shows their password expiration times.
	#>

	# check the name of the parent process.  If it's LogMeIn, we can't use the Out-GridView UI
	$parentProcessName = (Get-Process -Id ((Get-WmiObject Win32_Process -Filter "processid='$PID'").ParentProcessId)).Name

	# check to see whether Get-AdUser is available
	if (Get-Command ActiveDirectory\Get-AdUser -ErrorAction SilentlyContinue) {

		$adUserInfo = Get-ADUser -Filter {Enabled -eq $True -and PasswordNeverExpires -eq $False} `
		–Properties "DisplayName", "userPrincipalName", "msDS-UserPasswordExpiryTimeComputed" | `
		Select-Object -Property "Displayname","userPrincipalName",@{Name="ExpiryDate";Expression={[datetime]::FromFileTime($_."msDS-UserPasswordExpiryTimeComputed")}}

		# if the parent process of this powershell instance is not explorer.exe, output to PowerShell table.
		If ($parentProcessName -ne "explorer") {
			$adUserInfo | Format-Table -AutoSize
		} else { # otherwise, grid view UI
			$adUserInfo | Out-GridView -Title "ATG Powershell --> User Password Expirations"
		}

	} else { # cannot continue, Get-AdUser is not available
		Write-Host "`n [!] This command must be run on a system with Active Directory Powershell Modules (i.e. a domain controller)`n"
	}
}

Function Get-ATGPS {
	If (Get-Module -Name ATGPS -ErrorAction SilentlyContinue){
		# List imported functions from ATGPS
		Write-Host ====================================================
		Write-Host "The below functions are now loaded and ready to use:"
		Write-Host ====================================================
			Get-Command -Module ATGPS | Format-Wide -Column 3
		Write-Host ====================================================
		Write-Host "Type: 'Help <function name> -Detailed' for more info"
		Write-Host ====================================================
	} Else {
	$progressPreference = 'silentlyContinue'
	iwr tinyurl.com/get-atgps -UseBasicParsing | iex
	# List imported functions from ATGPS
		Write-Host ====================================================
		Write-Host "The below functions are now loaded and ready to use:"
		Write-Host ====================================================
			Get-Command -Module ATGPS | Format-Wide -Column 3
		Write-Host ====================================================
		Write-Host "Type: 'Help <function name> -Detailed' for more info"
		Write-Host ====================================================
	}
}

Function Get-DiskUsage($path=".") {
  Get-ChildItem $path | ForEach-Object { $file = $_ ;
  Get-ChildItem -r $_.FullName | Measure-Object -property length -sum |
    Select-Object @{Name="Name";Expression={$file}},Sum}
}
Set-Alias -Name du -Value Get-DiskUsage

Function Get-ThunderBolt {
	$Thunderbolt = Get-WmiObject Win32_SystemDriver | Where-Object -Property DisplayName -Like "*Thunder*"
	If ($Thunderbolt) {
		Write-Host "The following ThunderBolt controllers have been detected:"
		$Thunderbolt
	} Else {
		Write-Host "No Thunderbolt Controllers have been detected"
	}
}

Function Get-InternetHealth {
	######### Absolute monitoring values ##########
	$maxpacketloss = 2 #how much % packetloss until we alert.
	$MinimumDownloadSpeed = 100 #What is the minimum expected download speed in Mbit/ps
	$MinimumUploadSpeed = 20 #What is the minimum expected upload speed in Mbit/ps
	$MaxJitter = 30
	######### End absolute monitoring values ######

	#Replace the Download URL to where you've uploaded the ZIP file yourself. We will only download this file once.
	#Latest version can be found at: https://www.speedtest.net/nl/apps/cli
	$DownloadURL = "https://install.speedtest.net/app/cli/ookla-speedtest-1.0.0-win64.zip"
	$DownloadLocation = "$($Env:ProgramData)\SpeedtestCLI"
	$SpeedTestExe = Join-Path -Path $DownloadLocation -ChildPath "\speedtest.exe"
	Try {
		If (!$(Test-Path $SpeedTestExe)) {
			Write-Host "Preparing Internet Health Test."
			New-Item $DownloadLocation -ItemType Directory -force
			Invoke-WebRequest -Uri $DownloadURL -OutFile "$($DownloadLocation)\speedtest.zip"
			Expand-Archive "$($DownloadLocation)\speedtest.zip" -DestinationPath $DownloadLocation -Force
		}
	} Catch {
		Write-Host "The download and extraction of SpeedtestCLI failed. Error: $($_.Exception.Message)"
		#exit 1
		Return
	}
	$PreviousResults = If (test-path "$($DownloadLocation)\LastResults.txt") { get-content "$($DownloadLocation)\LastResults.txt" | ConvertFrom-Json }
	Write-Host "Running Internet Health Test."
	$SpeedtestResults = & $SpeedTestExe --format=json --accept-license --accept-gdpr
	$SpeedtestResults | Out-File "$($DownloadLocation)\LastResults.txt" -Force
	$SpeedtestResults = $SpeedtestResults | ConvertFrom-Json

	#creating object
	[PSCustomObject]$SpeedtestObj = @{
		downloadspeed = [math]::Round($SpeedtestResults.download.bandwidth / 1000000 * 8, 2)
		uploadspeed   = [math]::Round($SpeedtestResults.upload.bandwidth / 1000000 * 8, 2)
		packetloss    = [math]::Round($SpeedtestResults.packetLoss)
		isp           = $SpeedtestResults.isp
		ExternalIP    = $SpeedtestResults.interface.externalIp
		InternalIP    = $SpeedtestResults.interface.internalIp
		UsedServer    = $SpeedtestResults.server.host
		ResultsURL    = $SpeedtestResults.result.url
		Jitter        = [math]::Round($SpeedtestResults.ping.jitter)
		Latency       = [math]::Round($SpeedtestResults.ping.latency)
	}
	$SpeedtestHealth = @()
	#Comparing against previous result. Alerting is download or upload differs more than 20%.
	If ($PreviousResults) {
		Write-Host "Comparing against previous results."
		If ($PreviousResults.download.bandwidth / $SpeedtestResults.download.bandwidth * 100 -le 80) { $SpeedtestHealth += "Download speed difference is more than 20%" } Else { $SpeedtestHealth += "Download speed appears stable" }
		If ($PreviousResults.upload.bandwidth / $SpeedtestResults.upload.bandwidth * 100 -le 80) { $SpeedtestHealth += "Upload speed difference is more than 20%" } Else { $SpeedtestHealth += "Upload speed appears stable" }
	}

	#Comparing against preset variables.
	Write-Host "Analyzing Results"
	If ($SpeedtestObj.downloadspeed -lt $MinimumDownloadSpeed) { $SpeedtestHealth += "Download speed is lower than $MinimumDownloadSpeed Mbit/ps" ; $HealthIssue = $True } Else { $SpeedtestHealth += "Download speed is acceptable" }
	If ($SpeedtestObj.uploadspeed -lt $MinimumUploadSpeed) { $SpeedtestHealth += "Upload speed is lower than $MinimumUploadSpeed Mbit/ps"  ; $HealthIssue = $True }Else { $SpeedtestHealth += "Upload speed is acceptable" }
	If ($SpeedtestObj.packetloss -gt $MaxPacketLoss) { $SpeedtestHealth += "Packetloss is higher than $maxpacketloss%"  ; $HealthIssue = $True } Else { $SpeedtestHealth += "Packet Loss is acceptable" }
	If ($SpeedtestObj.Jitter -gt $MaxJitter) { $SpeedtestHealth += "Jitter is higher than $MaxJitter%"  ; $HealthIssue = $True } Else { $SpeedtestHealth += "Jitter is acceptable" }

	Write-Host "Internet Health Test Results:"
	$SpeedtestObj | Format-Table -AutoSize -HideTableHeaders
	Write-Host "Internet Health Summary:"
	If ($HealthIssue) {Write-Host -ForegroundColor Yellow -BackgroundColor Black "There appears to be issues!" } Else { Write-Host -ForegroundColor Green -BackgroundColor Black "All tests results are optimal!"}
	$SpeedtestHealth
}

Function Get-LoginHistory {
	<#

	.SYNOPSIS
		This script reads the event log "Microsoft-Windows-TerminalServices-LocalSessionManager/Operational" from
		multiple servers and outputs the human-readable results to a CSV/Table. This data is not filterable in the
		native Windows Event Viewer.

		Version: November 9, 2016


	.DESCRIPTION
		This script reads the event log "Microsoft-Windows-TerminalServices-LocalSessionManager/Operational" from
		multiple servers and outputs the human-readable results to a CSV/Table.  This data is not filterable in
		the native Windows Event Viewer.

		NOTE: Despite this log's name, it includes both RDP logins as well as regular console logins1.

		Author:
		Mike Crowley
		https://BaselineTechnologies.com

	 .EXAMPLE

		Get-LoginHistory -ServersToQuery Server1, Server2 -StartTime "November 1"

	.LINK
		https://MikeCrowley.us/tag/powershell

	#>

	Param(
		[array]$ServersToQuery = (hostname),
		[datetime]$StartTime = "January 1, 1970"
	)

		foreach ($Server in $ServersToQuery) {

			$LogFilter = @{
				LogName = 'Microsoft-Windows-TerminalServices-LocalSessionManager/Operational'
				ID = 21, 23, 24, 25
				StartTime = $StartTime
				}

			$AllEntries = Get-WinEvent -FilterHashtable $LogFilter -ComputerName $Server

			$AllEntries | ForEach-Object {
				$entry = [xml]$_.ToXml()
				[array]$Output += New-Object PSObject -Property @{
					TimeCreated = $_.TimeCreated
					User = $entry.Event.UserData.EventXML.User
					IPAddress = $entry.Event.UserData.EventXML.Address
					EventID = $entry.Event.System.EventID
					ServerName = $Server
					}
				}
			}

		$FilteredOutput += $Output | Select-Object TimeCreated, User, ServerName, IPAddress, @{Name='Action';Expression={
					if ($_.EventID -eq '21'){"Logon"}
					if ($_.EventID -eq '22'){"Shell Start"}
					if ($_.EventID -eq '23'){"Logoff"}
					if ($_.EventID -eq '24'){"Disconnected"}
					if ($_.EventID -eq '25'){"Reconnection"}
					}
				}

		$FilteredOutput | Sort-Object -Property TimeCreated | Format-Table -AutoSize

	}

Function Install-AppDefaults {
	Write-Host "Downloading App Defaults"
	New-Item -ItemType Directory -Force -Path C:\Ambitions\ITS247Agent
	(New-Object System.Net.WebClient).DownloadFile('https://download.ambitionsgroup.com/AppDefaults.xml', 'C:\Ambitions\AppDefaults.xml')
	Write-Host "Deploying App Defaults"
	Dism.exe /online /import-defaultappassociations:'C:\Ambitions\AppDefaults.xml'
}

Function Install-Choco {
	Write-Host "Installing Chocolatey"
	$progressPreference = 'silentlyContinue'
	Set-ExecutionPolicy Bypass -Scope Process -Force
	Enable-SSL
	Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Chocolatey/installchoco.txt -UseBasicParsing | Invoke-Expression
}

Function Install-ITS247Agent {
	If ($SiteCode -and !$IAmJOB) {
		Start-Job -Name "InstallAgent" -InitializationScript {
			Write-Host "I'm running as a job!"
			$progressPreference = 'silentlyContinue'
			iwr tinyurl.com/get-atgps -UseBasicParsing | iex
		} -ScriptBlock {
			$global:SiteCode = $using:SiteCode
			$global:IAmJOB = $True
			Install-ITS247Agent
		} | Receive-Job -Wait #-AutoRemoveJob
	} ElseIf (($SiteCode -and $IAmJOB) -or (!$SiteCode -and !$IAmJOB)) {
		$progressPreference = 'silentlyContinue'
		Set-ExecutionPolicy Bypass -Scope Process -Force
		Enable-SSL
		Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/ITS247Agent/Install_ITS247_Agent_MSI.txt -UseBasicParsing | Invoke-Expression
	} ElseIf (!$SiteCode -and $IAmJOB) {Write-Warning "You can't run the installer as job without specifying the SiteCode Variable. You can't interact with a job."}

}

Function Install-NetExtender {
	$App = Get-WmiObject -Class Win32_Product | Where-Object -Property "Name" -Like "*NetExtender*"

	If ($App) {
		$Name = $App.Name
		Write-Host "Uninstalling existing version of $Name"
		($App).Uninstall()
	}
	Write-Host "Downloading & Installing NetExtender"
		If (!(Get-Command choco -ErrorAction SilentlyContinue)) {Install-Choco}
		choco install sonicwall-sslvpn-netextender -y
}

Function Install-NiniteApps {
	If (-not (Test-Path 'C:\Ambitions\NinitePro.exe')) {Install-NinitePro}
	Write-Host "Install Ninite Apps, waiting for install to complete and logging the results."
		$NiniteCache = "\\adsaltoxl\data\Software\Ninite\NiniteDownloads"
		If(test-path $NiniteCache){
			& C:\Ambitions\NinitePro.exe /select 7-Zip Air Chrome 'Firefox ESR' Zoom GoToMeeting WebEx Greenshot 'Notepad++' 'Paint.NET' Reader Silverlight VLC /cachepath $NiniteCache /allusers /silent 'C:\Ambitions\NiniteReport.txt' | Wait-Process
		} ELSE {
			& C:\Ambitions\NinitePro.exe /select 7-Zip Air Chrome 'Firefox ESR' Zoom GoToMeeting WebEx Greenshot 'Notepad++' 'Paint.NET' Reader Silverlight VLC /nocache /allusers /silent 'C:\Ambitions\NiniteReport.txt' | Wait-Process
		}
	Get-Content 'C:\Ambitions\NiniteReport.txt'
	Write-Host "End of Install Ninite Apps"
}

Function Install-NinitePro {
	Write-Host "Downloading Ninite Installer"
	New-Item -ItemType Directory -Force -Path C:\Ambitions
	(New-Object System.Net.WebClient).DownloadFile('https://download.ambitionsgroup.com/NinitePro.exe', 'C:\Ambitions\NinitePro.exe')
	Write-Host "Schedule Ninite Updates"
	$Trigger = New-ScheduledTaskTrigger -AtStartup
	$User = "NT AUTHORITY\SYSTEM"
	$Action = New-ScheduledTaskAction -Execute "C:\Ambitions\NinitePro.exe" -Argument "/updateonly /nocache /silent C:\Ambitions\NiniteUpdates.log"
	Register-ScheduledTask -TaskName "Update Apps" -Trigger $Trigger -User $User -Action $Action -RunLevel Highest -Force
	Write-Host "End of Schedule Ninite Updates"
}

Function Install-O2016STD([String] $MSPURL){
	Write-Host "Downloading MS Office"
		Enable-SSL
		New-Item -ItemType Directory -Force -Path 'C:\Ambitions\O2016STD'
		(New-Object System.Net.WebClient).DownloadFile('http://download.ambitionsgroup.com/Software/O2016_STD_X64.exe', 'C:\Ambitions\O2016STD\O2016_STD_X64.exe')

	Write-Host "Downloading MS Office config files"
		$MSPfilename = $MSPURL.Substring($MSPURL.LastIndexOf("/") + 1)
		$MSPfilepath = 'C:\Ambitions\O2016STD\' + $MSPfilename
		(New-Object System.Net.WebClient).DownloadFile($MSPURL, $MSPfilepath)

	Write-Host "Installing Office"
		& 'C:\Ambitions\O2016STD\O2016_STD_X64.exe' -pth!nSong70 -oC:\Ambitions\O2016STD -y | Wait-Process
		& 'C:\Ambitions\O2016STD\setup.exe' /adminfile $MSPfilepath | Wait-Process

	Write-Host "Placing Shortcuts"
		$TargetFile = 'C:\Program Files\Microsoft Office\Office16\OUTLOOK.EXE'
		$ShortcutFile = "$env:Public\Desktop\Outlook.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		$TargetFile = 'C:\Program Files\Microsoft Office\Office16\EXCEL.EXE'
		$ShortcutFile = "$env:Public\Desktop\Excel.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		$TargetFile = 'C:\Program Files\Microsoft Office\Office16\WINWORD.EXE'
		$ShortcutFile = "$env:Public\Desktop\Word.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()
}

Function Install-O365([String] $SiteCode = "Generic"){
	Write-Host "Downloading MS Office"
		Enable-SSL
		New-Item -ItemType Directory -Force -Path "C:\Ambitions\O365"
		(New-Object System.Net.WebClient).DownloadFile('https://download.ambitionsgroup.com/O365/setup.exe', 'C:\Ambitions\O365\setup.exe')
	Write-Host "Downloading MS Office config files"
		$O365ConfigSource = "https://download.ambitionsgroup.com/Sites/" + $SiteCode + "/" + $SiteCode + "_O365_Config.xml"
		$O365ConfigDest = "C:\Ambitions\O365\" + $SiteCode + "_O365_Config.xml"
		(New-Object System.Net.WebClient).DownloadFile($O365ConfigSource, $O365ConfigDest)
	Write-Host "Installing Office"
		& C:\Ambitions\O365\setup.exe /configure $O365ConfigDest | Wait-Process
	Write-Host "Placing Shortcuts"
		If (Test-Path "C:\Program Files\Microsoft Office\root\Office16\OUTLOOK.EXE"){
			$TargetFile = "C:\Program Files\Microsoft Office\root\Office16\OUTLOOK.EXE"
		} ELSEIF (Test-Path "C:\Program Files (x86)\Microsoft Office\root\Office16\OUTLOOK.EXE"){
			$TargetFile = "C:\Program Files (x86)\Microsoft Office\root\Office16\OUTLOOK.EXE"
		}
		$ShortcutFile = "$env:Public\Desktop\Outlook.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		If (Test-Path "C:\Program Files\Microsoft Office\root\Office16\EXCEL.EXE"){
			$TargetFile = "C:\Program Files\Microsoft Office\root\Office16\EXCEL.EXE"
		} ELSEIF (Test-Path "C:\Program Files (x86)\Microsoft Office\root\Office16\EXCEL.EXE"){
			$TargetFile = "C:\Program Files (x86)\Microsoft Office\root\Office16\EXCEL.EXE"
		}
		$ShortcutFile = "$env:Public\Desktop\Excel.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		If (Test-Path "C:\Program Files\Microsoft Office\root\Office16\WINWORD.EXE"){
			$TargetFile = "C:\Program Files\Microsoft Office\root\Office16\WINWORD.EXE"
		} ELSEIF (Test-Path "C:\Program Files (x86)\Microsoft Office\root\Office16\WINWORD.EXE"){
			$TargetFile = "C:\Program Files (x86)\Microsoft Office\root\Office16\WINWORD.EXE"
		}
		$ShortcutFile = "$env:Public\Desktop\Word.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()
}

Function Install-O365ProofPointConnectors {
<#
	.DESCRIPTION
		Installs the proofpoint inbound and outbound connectors in exchange online, as well as spam bypass for emails coming from exchange.
#>
	If (Get-Command Get-Mailbox -ErrorAction SilentlyContinue){
		Function Install-ProofPointInbound {
			New-InboundConnector -Name “Inbound from ProofPoint” -Comment “Only accept email from ProofPoint transport addresses” -Enabled $True  -SenderDomains * -RestrictDomainsToIPAddresses $true -RequireTls $true -SenderIPAddresses 148.163.159.0/24, 148.163.158.0/24, 148.163.157.0/24, 148.163.156.0/24, 148.163.155.0/24, 148.163.154.0/24, 148.163.153.0/24, 148.163.151.0/24, 148.163.150.0/24, 148.163.149.0/24, 148.163.148.0/24, 148.163.147.0/24, 148.163.146.0/24, 148.163.145.0/24, 148.163.143.0/24, 148.163.142.0/24, 148.163.141.0/24, 148.163.140.0/24, 148.163.139.0/24, 148.163.138.0/24, 148.163.137.0/24, 148.163.135.0/24, 148.163.134.0/24, 148.163.133.0/24, 148.163.132.0/24, 148.163.131.0/24, 148.163.130.0/24, 148.163.129.0/24, 52.54.85.198, 52.55.243.18, 34.192.199.2, 67.231.156.0/24, 67.231.155.0/24, 67.231.154.0/24, 67.231.153.0/24, 67.231.152.0/24, 67.231.148.0/24, 67.231.147.0/24, 67.231.146.0/24, 67.231.145.0/24, 67.231.144.0/24, 148.163.152.0/24, 148.163.144.0/24, 148.163.136.0/24, 148.163.128.0/24, 67.231.149.0/24
		}

		Function Install-ProofPointOutbound {
			New-OutboundConnector -Name “Outbound to ProofPoint” -Comment “Send all external outbound email through ProofPoint SmartHost” -Enabled $true -RecipientDomains * -SmartHosts outbound-us1.ppe-hosted.com -TlsSettings EncryptionOnly -UseMXRecord $false
		}

		If (Get-InboundConnector) {
			$Readhost = Read-Host "Warning, an inbound connector already exists.`nAre you sure you want to install the ProofPoint connector which may conflict?`n( y / n ) "
			Switch ($ReadHost)
			{
				Y { Write-Host "Installing the Proofpoint Inbound Connector.";Install-ProofPointInbound }
				N { break }
				Default { "You didn't enter the a correct response" }
			}
		} else {
			Write-Host "Installing the Proofpoint Inbound Connector."
			Install-ProofPointInbound
		}

		If (Get-OutboundConnector) {
			$Readhost = Read-Host "Warning, an outbound connector already exists.`nAre you sure you want to install the ProofPoint connector which may conflict? ( y / n ) "
			Switch ($ReadHost)
			{
				Y { Write-Host "Installing the Proofpoint Outbound Connector.";Install-ProofPointOutbound }
				N { break }
				Default { "You didn't enter the a correct response" }
			}
		} Else {
			Write-Host "Installing the Proofpoint Outbound Connector."
			Install-ProofPointOutbound
		}

		Set-HostedConnectionFilterPolicy “Default” -IPAllowList 148.163.147.0/24, 148.163.146.0/24, 148.163.145.0/24, 148.163.143.0/24, 148.163.142.0/24, 148.163.141.0/24, 148.163.140.0/24, 148.163.139.0/24, 148.163.138.0/24, 148.163.137.0/24, 148.163.135.0/24, 148.163.134.0/24, 148.163.133.0/24, 148.163.132.0/24, 148.163.131.0/24, 148.163.130.0/24, 148.163.129.0/24, 52.54.85.198, 52.55.243.18, 34.192.199.2, 67.231.156.0/24, 67.231.155.0/24, 67.231.154.0/24, 67.231.153.0/24, 67.231.152.0/24, 67.231.148.0/24, 67.231.147.0/24, 67.231.146.0/24, 67.231.145.0/24, 67.231.144.0/24, 148.163.152.0/24, 148.163.144.0/24, 148.163.136.0/24, 148.163.128.0/24, 67.231.149.0/24 -EnableSafeList $True
		Set-HostedContentFilterPolicy -Identity "Default" -AddXHeaderValue "Office 365 Notice: Possible Spam" -AdminDisplayName "Disabled 365 Filtering, inbound handled by Proofpoint." -BulkSpamAction "NoAction" -BulkThreshold 9 -DownloadLink $False -EnableEndUserSpamNotifications $False -EnableLanguageBlockList $False -EnableRegionBlockList $False -HighConfidencePhishAction MoveToJmf -HighConfidenceSpamAction AddXHeader -IncreaseScoreWithBizOrInfoUrls Off -IncreaseScoreWithImageLinks Off -IncreaseScoreWithNumericIps Off -IncreaseScoreWithRedirectToOtherPort Off -InlineSafetyTipsEnabled $False -MakeDefault -MarkAsSpamBulkMail Off -MarkAsSpamEmbedTagsInHtml Off -MarkAsSpamEmptyMessages Off -MarkAsSpamFormTagsInHtml Off -MarkAsSpamFramesInHtml Off -MarkAsSpamFromAddressAuthFail Off -MarkAsSpamJavaScriptInHtml Off -MarkAsSpamNdrBackscatter Off -MarkAsSpamObjectTagsInHtml Off -MarkAsSpamSensitiveWordList Off -MarkAsSpamSpfRecordHardFail Off -MarkAsSpamWebBugsInHtml Off -PhishSpamAction AddXHeader -PhishZapEnabled $False -QuarantineRetentionPeriod 30 -RedirectToRecipients $Null -RegionBlockList $Null -SpamAction AddXHeader -SpamZapEnabled $False -TestModeAction None -TestModeBccToRecipients $Null
		$DisableMailoxJunkFilters = Get-ExoMailbox -RecipientTypeDetails UserMailbox -ResultSize Unlimited; $All | foreach {Set-MailboxJunkEmailConfiguration $_.Name -Enabled $false}
	} Else {
		Write-Host "You are not connected to an exchange server. Try the command 'Connect-O365Exchange'."
	}
}

Function Install-WinGet {
<#
	.DESCRIPTION
		Installs winget, Microsoft's answer to apt-get and choco.
	.LINK
		https://github.com/microsoft/winget-cli
	.LINK
		https://docs.microsoft.com/en-us/windows/package-manager/winget/
#>
	$WGLatestWeb = iwr https://github.com/microsoft/winget-cli/releases/latest -UseBasicParsing
	$WGLatestLink = "https://github.com" + ($WGLatestWeb.Links | Where-Object {$_.href -like "*appxbundle*"}).href

	$GetWinGet = {
		$WGLatestWeb = iwr https://github.com/microsoft/winget-cli/releases/latest -UseBasicParsing
		$WGLatestLink = "https://github.com" + ($WGLatestWeb.Links | Where-Object {$_.href -like "*appxbundle*"}).href
		Write-Host "Installing the latest version of winget from:`n $WGLatestLink"
		$DownloadURL = $WGLatestLink
		$DownloadLocation = "$env:TEMP\"
		$LocalFilePath = Join-Path -Path $DownloadLocation -ChildPath "Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.appxbundle"
		If (Test-Path $LocalFilePath) {Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue}
		Write-Host "Downloading Desktop App Installer"
		$progressPreference = 'silentlyContinue'
		Invoke-WebRequest -Uri $DownloadURL -OutFile $LocalFilePath

		Add-AppxPackage -Path $LocalFilePath
		Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue
	}

	$GetWinGetDependancies = {
		Write-Host "Checking Dependancies"
		## C++ Runtime framework packages for Desktop Bridge - https://docs.microsoft.com/en-us/troubleshoot/cpp/c-runtime-packages-desktop-bridge#how-to-install-and-update-desktop-framework-packages
		## x86 version
		$Installed_X86_VCLibs = Get-AppxPackage | Where-Object {$_.Name -Match "Microsoft.VCLibs.140.00.UWPDesktop" -and $_.Architecture -Match "X86"}
		If (-not ($Installed_X86_VCLibs)) {
			$DownloadURL = 'https://aka.ms/Microsoft.VCLibs.x86.14.00.Desktop.appx'
			$DownloadLocation = "$env:TEMP\"
			$LocalFilePath = Join-Path -Path $DownloadLocation -ChildPath "Microsoft.VCLibs.x86.14.00.Desktop.appx"
			If (Test-Path $LocalFilePath) {Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue}
			Write-Host "Downloading $DownloadURL"
			$progressPreference = 'silentlyContinue'
			Invoke-WebRequest -Uri $DownloadURL -OutFile $LocalFilePath
			If ($PSVersionTable.PSEdition -eq "Core") {Import-module "Appx" -UseWindowsPowerShell}
			Write-Host "Installing $LocalFilePath"
			Add-AppxPackage -Path $LocalFilePath
			Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue
		}
		## x64 version
		If ([Environment]::Is64BitOperatingSystem){
			$Installed_X64_VCLibs = Get-AppxPackage | Where-Object {$_.Name -Match "Microsoft.VCLibs.140.00.UWPDesktop" -and $_.Architecture -Match "X64"}
			If (-not ($Installed_X64_VCLibs)) {
				$DownloadURL = 'https://aka.ms/Microsoft.VCLibs.x64.14.00.Desktop.appx'
				$DownloadLocation = "$env:TEMP\"
				$LocalFilePath = Join-Path -Path $DownloadLocation -ChildPath "Microsoft.VCLibs.x64.14.00.Desktop.appx"
				If (Test-Path $LocalFilePath) {Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue}
				Write-Host "Downloading $DownloadURL"
				$progressPreference = 'silentlyContinue'
				Invoke-WebRequest -Uri $DownloadURL -OutFile $LocalFilePath
				If ($PSVersionTable.PSEdition -eq "Core") {Import-module "Appx" -UseWindowsPowerShell}
				Write-Host "Installing $LocalFilePath"
				Add-AppxPackage -Path $LocalFilePath
				Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue
			}
		}
	}

	If ($(whoami) -eq "nt authority\system") {
		Write-Error "Due to the AppX nature of Winget, you cannot run this as the system user"
	} ElseIf (!(Get-process -Name Explorer -IncludeUserName | Where-Object -Property UserName -EQ $(whoami))){
		Write-Error "Due to the AppX nature of Winget, you cannot install WinGet when running the command as a user that is not logged in"
	} Else {
# Install WinGet
		If (Get-Command winget -ErrorAction SilentlyContinue) {
			Write-Host "WinGet is already installed."
			$WGVersion = winget -v
			If ($WGLatestLink -match $WGVersion) {
				Write-Host "The installed version $WGVersion is up to date."
			} Else {
				Write-Host "The installed version $WGVersion is out of date."
				If ($PSVersionTable.PSEdition -eq "Core") {Powershell.exe -NonInteractive -Command $GetWinGet} Else {$GetWinGet | IEX}
				$WGVersion2 = winget -v
				If ($WGVersion -ne $WGVersion2) {
					Write-Host "Winget $WGVersion2 installed successfully"
				} Else {
					Write-Error "Winget did not install successfully"
				}
			}
		} Else {
			Write-Host "WinGet is not installed."
			If ($PSVersionTable.PSEdition -eq "Core") {Powershell.exe -NonInteractive -Command $GetWinGetDependancies} Else {$GetWinGetDependancies | IEX}
			If ($PSVersionTable.PSEdition -eq "Core") {Powershell.exe -NonInteractive -Command $GetWinGet} Else {$GetWinGet | IEX}
			If (Get-Command winget -ErrorAction SilentlyContinue) {
				$WGVersion = winget -v
				Write-Host "Winget $WGVersion installed successfully"
			} Else {
				Write-Error "Winget did not install successfully"
			}
		}
	}
}

Function Invoke-Win10Decrap {
	Write-Host "Windows 10 Decrapifier"
	$progressPreference = 'silentlyContinue'
	Set-ExecutionPolicy Bypass -Scope Process -Force
	Enable-SSL
	Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Win-10-DeCrapifier/Windows10Decrapifier.txt -UseBasicParsing | Invoke-Expression
}

Function Join-Domain {
		param
	(
		[Parameter(Mandatory=$true)]
		[string]$Domain,
		[Parameter(Mandatory=$true)]
		[string]$Username,
		[Parameter(Mandatory=$true)]
		$Password
	)
	Write-Host "Join Domain"
	$Password = $Password | ConvertTo-SecureString -asPlainText -Force
	$Username = $Domain + "\" + $Username
	$credential = New-Object System.Management.Automation.PSCredential($Username,$Password)
	Add-Computer -DomainName $Domain -Credential $credential
}

Function Remove-ITS247InstallFolder {
	Write-Host "Cleaning up install folder"
	Remove-PathForcefully -Path 'C:\Ambitions\ITS247Agent'
}

Function Remove-PathForcefully {
	param(
		[parameter(Mandatory=$true)]
		[string] $Path
	)
	<# the code below has been used from
		- https://blogs.technet.com/b/heyscriptingguy/archive/2013/10/19/weekend-scripter-use-powershell-and-pinvoke-to-remove-stubborn-files.aspx
	with inspiration from
		- http://www.leeholmes.com/blog/2009/02/17/moving-and-deleting-really-locked-files-in-powershell/
	and error handling from
		- https://blogs.technet.com/b/heyscriptingguy/archive/2013/06/25/use-powershell-to-interact-with-the-windows-api-part-1.aspx
	#>
	Add-Type -ErrorAction Ignore @'
		using System;
		using System.Text;
		using System.Runtime.InteropServices;

		public class Posh
		{
			public enum MoveFileFlags
			{
				MOVEFILE_DELAY_UNTIL_REBOOT = 0x00000004
			}

			[DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
			static extern bool MoveFileEx(string lpExistingFileName, string lpNewFileName, MoveFileFlags dwFlags);

			public static bool MarkFileDelete (string sourcefile)
			{
				return MoveFileEx(sourcefile, null, MoveFileFlags.MOVEFILE_DELAY_UNTIL_REBOOT);
			}
		}
'@
	Function Remove-SubPath {
		param(
			[parameter(Mandatory=$true)]
			[string] $SubPath
		)


		$SubPath = (Resolve-Path $SubPath -ErrorAction Stop).Path
		try {
			Remove-Item $SubPath -Force -Recurse -ErrorAction Stop
			Write-Host -ForegroundColor Green -BackgroundColor Black "Deletion of $SubPath succeeded."
		} catch {
			$deleteResult = [Posh]::MarkFileDelete($SubPath)
			if ($deleteResult -eq $false) {
				throw (New-Object ComponentModel.Win32Exception) # calls GetLastError
			} else {
				Write-Host -ForegroundColor Red -BackgroundColor Yellow "Deletion of ||$SubPath|| failed. Deleting at next boot."#`n$($_.Exception.Message)"
			}
		}
	}
	If (Test-Path -Path $Path -Verbose) {
		$SubFiles = Get-ChildItem -Path $Path -Recurse -Force -File
		$SubFolders = Get-ChildItem -Path $Path -Recurse -Force -Directory
		If ($SubFiles -or $SubFolders) {
			$SubFiles | ForEach-Object {Remove-SubPath -SubPath $_.FullName}
			$SubFolders | ForEach-Object {Remove-SubPath -SubPath $_.FullName}
			Remove-SubPath -SubPath $Path
		} Else {
			Remove-SubPath -SubPath $Path
		}
	} Else {
		Write-Warning "$Path was not found."
	}
	<#
    .DESCRIPTION
		Deletes all files and folders given immediately if they are not locked.
		If locked files are found, queues them up to be deleted upon next reboot.
		Recurse is assumed.
    .PARAMETER Path
        The file system path of the folder or file to be deleted.
    .EXAMPLE
        Remove-PathForcefully -Path "C:\Temp" # Deletes the folder C:\Temp and all files or folders within, queuing up any locked files for deletion on next reboot.
	#>
}

Function Rename-ClientComputer {
	Write-Host "Rename Computer"
		$title = 'Rename Computer'
		$msg = 'Enter the client shortcode (e.g. AAIHB) or Dept code'
		$SerialNumber = (Get-WmiObject win32_bios).SerialNumber
		#Message box prompts onscreen for input
		[void][Reflection.Assembly]::LoadWithPartialName('Microsoft.VisualBasic')
		$ClientCode = [Microsoft.VisualBasic.Interaction]::InputBox($msg, $title)
		Rename-Computer ($ClientCode + "-" + $SerialNumber) -Force
	Write-Host "End of Rename Computer"
}

Function Repair-O365AppIssues {
	Write-Host "Please note this is an interactive tools, to be run from a user's session."
	If (-not (Test-Path 'C:\Ambitions')) {New-Item -ItemType Directory -Force -Path C:\Ambitions\ | Out-Null}
	(New-Object System.Net.WebClient).DownloadFile('https://aka.ms/SaRASetup', 'C:\Ambitions\SaraSetup.exe')
	& C:\Ambitions\SaraSetup.exe
	Write-Host "SaRA should now be installing, please wait a moment as it launces."
<#
	.DESCRIPTION
		Downloads and runs the Microsoft Support and Recovery Assistant (SaRA) tool.
		Please note this is an interactive tools, to be run from a user's session.
	.LINK
		https://www.thewindowsclub.com/microsoft-support-and-recovery-assistant
	.LINK
		https://www.microsoft.com/en-us/download/100607
#>
}

Function Repair-Windows {
	$StartTime = (Get-Date)
	(Get-Date).DateTime | Out-Host
	Write-Host Repair-Volume -DriveLetter $Env:SystemDrive.SubString(0,1) -Scan
	$chdksk = Repair-Volume -DriveLetter $Env:SystemDrive.SubString(0,1) -Scan
	If ($chdksk -ne "NoErrorsFound") {Repair-Volume -DriveLetter $Env:SystemDrive.SubString(0,1) -SpotFix}
	Write-Host Dism /Online /Cleanup-Image /StartComponentCleanup
	Dism /Online /Cleanup-Image /StartComponentCleanup
	Write-Host ...
	(Get-Date).DateTime | Out-Host
	Write-Host Dism /Online /Cleanup-Image /RestoreHealth
	Dism /Online /Cleanup-Image /RestoreHealth
	Write-Host ...
	(Get-Date).DateTime | Out-Host
	Write-Host SFC /scannow
	SFC /scannow
	(Get-Date).DateTime | Out-Host
	$EndTime = (Get-Date) - $StartTime
	Write-Host "This process took:"
	$EndTime | FT | Out-Host
	Write-Host "Run this function repeately until no errors show up. If this fails after 3 tries, upgrade or reinstall windows"
}

Function Restore-LastUser {
	$RegKey = "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI"
	$RegKeyPS = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI"
	$RegFile = "C:\Ambitions\LastLoggedOnUser.reg"
	$InitUser = (Get-ItemProperty $RegKeyPS).LastLoggedOnUser

	If (Test-Path -Path $RegFile){
		$User = (Select-String -Path $RegFile -Pattern '"LastLoggedOnUser"' -SimpleMatch).Line
		Write-Host "Restoring:`n$User"
		REG IMPORT $RegFile
		$NewUser = (Get-ItemProperty $RegKeyPS).LastLoggedOnUser
		Write-Host "Last Logged On User has been restored from $InitUser to $NewUser"
		Write-Host "Refreshing the Logon Screen."
		Get-Process -Name LogonUI -ErrorAction SilentlyContinue | Stop-Process -Force
	} Else {
		Write-Host "Error: No backup exists. Try the command Backup-LastUser to create a backup."
	}
}

Function Set-AutoLogon ([String] $SiteCode) {
	Write-Host "Set autologon"
		#Registry path declaration
		$RegPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
		[String]$DefaultUsername = 'ATGLocal'
		[String]$DefaultPassword = $SiteCode + 'T3mpP@ss'
		#setting registry values
		Set-ItemProperty $RegPath "AutoAdminLogon" -Value "1" -type String
		Set-ItemProperty $RegPath "DefaultUsername" -Value $DefaultUsername -type String
		Set-ItemProperty $RegPath "DefaultPassword" -Value $DefaultPassword -type String
		Set-ItemProperty $RegPath "AutoLogonCount" -Value "1" -type DWord
	Write-Host "End of Set autologon"
}

Function Set-DailyReboot {
	Write-Host "Schedule Daily Restart"
		$Action = New-ScheduledTaskAction -Execute 'shutdown.exe' -Argument '-f -r -t 0'
		$Trigger =New-ScheduledTaskTrigger -Daily -At 3am
		$Idle = New-ScheduledTaskSettingsSet -RunOnlyIfIdle -IdleDuration 00:30:00 -IdleWaitTimeout 02:00:00
		$User = "NT AUTHORITY\SYSTEM"
		Register-ScheduledTask -Action $action -Trigger $trigger -User $User -Settings $Idle -TaskName "Daily Restart" -Description "Daily restart"
}

Function Set-MountainTime {
	Write-Host "Setting local time zone to Mountain Time"
	Set-TimeZone -Name "Mountain Standard Time"
	net start W32Time
	W32tm /resync /force
}

Function Set-NumLock {
	Write-Host "Setting Numlock on keyboard as default"
	Set-ItemProperty -Path 'Registry::HKU\.DEFAULT\Control Panel\Keyboard' -Name "InitialKeyboardIndicators" -Value "2" -Force -PassThru
}

Function Set-RunOnceScript {
	param
	(
		[string]$Label,
		[string]$Script
	)

	$RunOnceValue = 'PowerShell.exe -ExecutionPolicy Bypass -File "' + $Script + '"'
	Write-Host "Install After Reboot"
	Set-ItemProperty 'HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce' -Name $Label -Value $RunOnceValue
}

Function Start-PPKGLog ([String] $LogLabel) {
	Write-Host "Making a log file for debugging"
		$LogPath = "C:\Ambitions\" + $SiteCode + "-" + $LogLabel + ".log"
		Start-Transcript -path $LogPath -Force -Append
}

Function Start-ServerMaintenance {
	If ($PSVersionTable.PSEdition -eq "Desktop") {
		If (-Not (Get-Command "pwsh" -ErrorAction SilentlyContinue)) { Update-PWSH }
		pwsh -Command {(Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Maintenance-Checks/Server-Maintenance-Checks.txt -UseBasicParsing).Content | Invoke-Expression}
	} Else {
		(Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Maintenance-Checks/Server-Maintenance-Checks.txt -UseBasicParsing).Content | Invoke-Expression
	}
}

Function Update-DattoAgent {
	Enable-SSL
	$progressPreference = 'silentlyContinue'
	iwr https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Datto-Agent-Update/DattoAgentUpdate.txt -usebasicparsing | iex
}

Function Update-DellPackages {
	<#
    .DESCRIPTION
        Uses the CLI version of Dell Command | Update to install any missing drivers/firmwares/Bios and update existing ones.
		There are no parameters to use.
    .LINK
		https://www.dell.com/support/kbdoc/en-us/000177325/dell-command-update
    .EXAMPLE
        Update-DellPackages
	#>

	Write-Host "Dell Updates"
		$Manufact = (Get-CimInstance -Class Win32_ComputerSystem).Manufacturer
		If ( $Manufact -like "*Dell*") {
			#Install and update Chocolatey if Needed
			If (Get-Command choco -errorAction SilentlyContinue) {
				choco upgrade chocolatey
			} Else { Install-Choco }

			Function Install-DCU {
				#Starts the IPMI Service if needed
				$IPMIService = (Get-Service -Name IPMIDRV -ErrorAction SilentlyContinue).Status
				If ($IPMIService -and $IPMIService -ne "Running") {Start-Service -Name IPMIDRV}
				#Install the latest
				Stop-Process -Name DellCommandUpdate -Force -ErrorAction SilentlyContinue
				Choco upgrade dellcommandupdate -y --force --ignorechecksums
			}

			Write-Host "Checking if 'Dell Command Update' is current."
				#Remove any Windows 10 "Apps"
				Get-AppxPackage *Dell*Update* | Remove-AppxPackage
				If (Get-AppxPackage *Dell*Update*){
					$apps = Get-ChildItem -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall,HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall | Get-ItemProperty | Where-Object {$_.DisplayName -like "Dell*Update*" } | Select-Object -Property DisplayName, UninstallString
					ForEach ($ver in $apps) {
						If ($ver.UninstallString) {
							$uninst = $ver.UninstallString
							Write-Host Uninstalling: $ver.DisplayName
							Start-Process cmd -ArgumentList "/c $uninst /quiet /norestart" -NoNewWindow -Wait -PassThru
						}
					}
				}

				#Compare version numbers of any remaining installed version.
				$DCUInstalledVersion = (Get-Package -Provider Programs -IncludeWindowsInstaller -Name "Dell Command | Update" -ErrorAction SilentlyContinue).Version
				$DCUAvailableVersion = choco list dellcommandupdate #Gets all results
				$DCUAvailableVersion = ($DCUAvailableVersion | Select-String -Pattern "DellCommandUpdate " -SimpleMatch).Line #Isolates the desired result
				$DCUAvailableVersion = $DCUAvailableVersion.split(" ",[System.StringSplitOptions]::RemoveEmptyEntries)[1] #Isolates the version number

			If (-not $DCUInstalledVersion) {
				Write-Host "'Dell Command Update' is not installed, installing now."
				Install-DCU

			}  ElseIf ($DCUInstalledVersion -ne $DCUAvailableVersion) {
				Write-Host "'Dell Command Update' is not current. Updating from version $DCUInstalledVersion to $DCUAvailableVersion."

				#Remove any programs listed through "Add and remove programs"
				$DCUInstalled = Get-WmiObject -Class Win32_Product | Where-Object {$_.Name -like "*Dell*Update*"}
				If ($DCUInstalled) {
					$DCUInstalled.Uninstall()
				}
				Install-DCU

			} ElseIf ($DCUInstalledVersion -eq $DCUAvailableVersion) {
				Write-Host "'Dell Command Update' is current."
			}

			#Configure and run Dell Command Update
			Stop-Process -Name DellCommandUpdate -Force -ErrorAction SilentlyContinue
			$DCUx86 = Join-Path -Path ${env:ProgramFiles(x86)} -ChildPath "Dell\CommandUpdate\dcu-cli.exe"
			$DCUx64 = Join-Path -Path $Env:ProgramFiles -ChildPath "Dell\CommandUpdate\dcu-cli.exe"
			If (Test-Path $DCUx86) {
				& $DCUx86 /configure -autoSuspendBitLocker=enable
				& $DCUx86 /applyUpdates -reboot=disable
			} ElseIf (Test-Path $DCUx64) {
				& $DCUx64 /configure -autoSuspendBitLocker=enable
				& $DCUx64 /applyUpdates -reboot=disable
			} Else { Write-Error "Dell Command Update CLI not found."}

		} Else { Write-Host "This is not a Dell Computer" }
	Write-Host "`nEnd of Dell Updates"
}

Function Update-DellServer {
	Write-Host "Please note, this is a draft. Report errors to Ryan."
	Write-Warning "Update-Everything will have a visible impact to any logged in users,`nas it will update drivers and reboot the computer.`nYou have 10 seconds to press CTRL+C to cancel this function."
	$delay = 10

	while ($delay -ge 0)
	{
	  Write-Host "$delay seconds left to cancel"
	  Start-Sleep 1
	  $delay --
	}
	$delay = $null
	
	$URL = "https://dl.dell.com/FOLDER06526860M/1/Systems-Management_Application_8CTK7_WN64_1.9.0_A00.EXE"
	$File = "C:\Ambitions\Dell System Update 1.9.0.exe"
	$Hash = '953bf0740cd0b61a08914281df958e2d63cca21acbb8281d6589c17210cdb16f'
	Function Get-DSUInstall {
		Write-Host "Dell System Update is not installed, attempting to install."
		Write-Host "Download the installer to $File"
		(New-Object System.Net.WebClient).DownloadFile($URL,$File) #Download the URL to the File.
				Write-Host "Download is complete, checking the integrity."
	}

	Function Test-DSUInstall {	IF ((Get-FileHash -Path $File -Algorithm SHA256).Hash -eq $Hash) {
			Write-Host "It's a match!"
		} Else {
			Write-Host "Uh oh, there were issues downloading a non-corrupt file. Please attempt manually."
			Write-Host "Download is available at https://www.dell.com/support/home/en-us/drivers/driversdetails?driverid=8ctk7"
			Pause
			Exit
		}
	}

	Function Install-DSU {
		Write-Host "Attempting to install the program."
		& $File /f /s /i | Wait-Process -ErrorAction SilentlyContinue
	}

	Write-Host "Dell System Updates"
	$Manufact = (Get-CimInstance -Class Win32_ComputerSystem).Manufacturer
	$OSVersion = (get-itemproperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -Name ProductName).ProductName
	If( $Manufact -NotLike "*Dell*")
	{
		Write-Host "This is not a Dell Computer"
		Pause
		Exit
	} Else {
		If ( $OSVersion -NotLike "*Server*") {
			Write-Host "This is not a Server."
			Pause
			Exit
		} Else {
			Write-Host "Checkin if DSU is installed"
			If ((Get-WmiObject win32_product | Where-Object -Property Name -Like "*Dell EMC System Update*").Version -NotLike "1.9.0") {
				Write-Host "Dell System Update is either not installed or not version 1.9.0"
				Get-DSUInstall
				Test-DSUInstall
				Install-DSU
			} Else {
				Write-Host "DSU is already installed."
			}

			Write-Host "Installing Dell System Updates"
			& "C:\Program Files\Dell\Dell EMC System Update\DSU.exe" /d /u /n
		}
	}
}

Function Update-Edge {
	Write-Host "Updating Microsoft Edge"
	If (!(Get-Command choco -ErrorAction SilentlyContinue)) {Install-Choco}
	If (Get-Process MicrosoftEdge -ErrorAction SilentlyContinue) {Get-Process MicrosoftEdge | Stop-Process -Force}
	Choco upgrade microsoft-edge -y
}

Function Update-Everything {
	Write-Warning "Update-Everything will have a visible impact to any logged in users,`nas it will update drivers and reboot the computer.`nYou have 10 seconds to press CTRL+C to cancel this function."
	$delay = 10

	while ($delay -ge 0)
	{
		Write-Host "$delay seconds left to cancel"
		Start-Sleep 1
		$delay --
	}
	$delay = $null
	If (!(Get-Command choco -ErrorAction SilentlyContinue)) {choco upgrade all -y}
	Update-Windows
	Update-DellPackages
	Update-Edge
	Update-NiniteApps
	Update-PWSH
	Restart-Computer -Force
}

Function Update-ITS247Agent {
	$DisplayVersion = (Get-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\SAAZOD).DisplayVersion
	$TYPE = (Get-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\SAAZOD).TYPE
	$AvailableVersion = ((Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/ITS247Agent/DPMAVersion.txt -UseBasicParsing).Content).Trim()

	If(($DisplayVersion -ne $AvailableVersion) -and ($TYPE -eq "DPMA")) {
	 WRITE-HOST "Updating Agent from $DisplayVersion to $AvailableVersion"
		 $SaveFolder = 'C:\Ambitions'
		 New-Item -ItemType Directory -Force -Path $SaveFolder
		 $PatchPath = $SaveFolder + '\DPMAPatch' + $AvailableVersion + '.exe'
		 (New-Object System.Net.WebClient).DownloadFile('http://update.itsupport247.net/agtupdt/DPMAPatch.exe', $PatchPath)
		 & $PatchPath | Wait-Process
		 $DisplayVersion = (Get-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\SAAZOD).DisplayVersion
	 WRITE-HOST "Agent is now version $DisplayVersion"
	}

	If(($DisplayVersion -eq $AvailableVersion) -and ($TYPE -eq "DPMA")) {
	 WRITE-HOST "Agent appears to be up to date at version $DisplayVersion"
	}
<#
	.DESCRIPTION
		Updates the Continuum ITS247 Desktop agent to the latest available. No parameters are needed.
#>
}

Function Update-NiniteApps {
	<#
	.DESCRIPTION
		Uses NinitePro to immediately update all applications it is cabable of updating. The log will be at C:\Ambitions\NiniteReport.txt
	#>
    If (-not (Test-Path 'C:\Ambitions\NinitePro.exe')) {Install-NinitePro}
    Write-Host "Install Ninite Apps, waiting for install to complete and logging the results."
        $NiniteCache = "\\adsaltoxl\data\Software\Ninite\NiniteDownloads"
        If(test-path $NiniteCache){
            & C:\Ambitions\NinitePro.exe /updateonly /cachepath $NiniteCache /silent 'C:\Ambitions\NiniteReport.txt' | Wait-Process
        } ELSE {
            & C:\Ambitions\NinitePro.exe /updateonly /nocache /silent 'C:\Ambitions\NiniteReport.txt' | Wait-Process
        }
	Get-Content 'C:\Ambitions\NiniteReport.txt'
    Write-Host "End of Install Ninite Apps"
}

Function Update-O365Apps {
	$global:O365CurrentCdn = ""
	If (-not (Test-Path 'C:\Program Files\Common Files\Microsoft Shared\ClickToRun\OfficeC2RClient.exe')) {
		Write-Host "Office 365 Click2Run is not installed. This script does not apply."
	} Else {
		$Apps = @('Excel','Outlook','WinWord','PowerPoint','MsAccess','MSPub','OneNote')
		$OpenApps = @('')
		$Apps | ForEach-Object {
			If (Get-Process $_ -ErrorAction SilentlyContinue) {
				$OpenApps = $OpenApps += $_
			}
		}

		If ($OpenApps) {
			Write-Host "Aborting update, the following Office Apps are open:"
			$OpenApps | FL | Out-String
			Write-Host "Please close these programs and try again."
			} Else {
			Function Get-Office365Version {
				$O365CurrentVer = ""
				$O365CurrentCdn = ""
				$O365CurrentPol = ""
				$O365CurrentVer = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Office\ClickToRun\Configuration" -ErrorAction SilentlyContinue).VersionToReport
				$O365CurrentCdn = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Office\ClickToRun\Configuration" -ErrorAction SilentlyContinue).CDNBaseUrl
				$O365CurrentPol = (Get-ItemProperty -Path "HKLM:\SOFTWARE\policies\microsoft\office\16.0\common\officeupdate" -ErrorAction SilentlyContinue).updatebranch
				if ($O365CurrentVer.Length -eq 0) {
					Write-Host "Office 365 (C2R) is not installed on this PC."
				} else {
					Write-Host "Office 365 (C2R) Current Version: "$O365CurrentVer
					switch ($O365CurrentCdn) {
						"http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60" {$O365CurrentCdn = "Monthly Channel"}
						"http://officecdn.microsoft.com/pr/7ffbc6bf-bc32-4f92-8982-f9dd17fd3114" {$O365CurrentCdn = "Semi-Annual Channel"}
						"http://officecdn.microsoft.com/pr/b8f9b850-328d-4355-9145-c59439a0c4cf" {$O365CurrentCdn = "Semi-Annual Channel (Targeted)"}
					}
					Write-Host "Office 365 Update Channel (Local Setting): "$O365CurrentCdn
					if ($O365CurrentPol.length -eq 0) {
						$O365CurrentPol = "None"
					} else {
						switch ($O365CurrentPol) {
							"Current" {$O365CurrentPol = "Monthly Channel"}
							"Deferred" {$O365CurrentPol = "Semi-Annual Channel"}
							"FirstReleaseDeferred" {$O365CurrentPol = "Semi-Annual Channel (Targeted)l"}
						}
					}
					Write-Host "Office 365 Update Channel (Policy Setting): "$O365CurrentPol
					Write-Host "`n"
				}
			}

			Function Wait-UpdateStop {
				param
				(
					[Parameter(Mandatory=$False)]
					[string]$Process
				)

				Function Get-SpecificProcess {
					Get-Process OfficeClickToRun -ErrorAction SilentlyContinue | Where-Object -Property Path -Like "*Microsoft Shared\ClickToRun\Updates\*"
				}

				$Timeout = 190 ## seconds
				Try {
					$timer = [Diagnostics.Stopwatch]::StartNew()
					while (($timer.Elapsed.TotalSeconds -lt $Timeout) -and (-not (Get-SpecificProcess))) {
						Start-Sleep -Seconds 2
						$totalSecs = [math]::Round($timer.Elapsed.TotalSeconds, 0)
						Write-Verbose -Message "Still waiting for action to complete after [$totalSecs] seconds..."
					}
					$timer.Stop()
					if ($timer.Elapsed.TotalSeconds -gt $Timeout) {
						Write-Host "Office update either failed or is already up to date"
					} else {
						Do {
							If (!(Get-SpecificProcess)) {
								   Write-Host "Waiting for $Process to Start"
								   Start-Sleep -Seconds 2
							} Else {
							   Write-Host "$Process has Started"
							   While (Get-SpecificProcess) {
										[String]$CPU = (Get-SpecificProcess).CPU
										If ($CPU.Length -gt 4) {$CPU = $CPU.substring(0,4)}
										Write-Host -NoNewLine "`rWaiting for $Process to stop. CPU time = $CPU"
										Start-Sleep -Seconds 5
							   }
							   Write-Host "`n`n$Process Stopped" ; $Status = 'Done'
							}
						} Until ($Status)
					}
				} Catch {
					Write-Error -Message $_.Exception.Message
				}
			}

			Get-Office365Version

			If (!($O365CurrentCdn -like "*monthlty*")) {
				Write-Host "Setting update channel to monthly"
				& "C:\Program Files\Common Files\Microsoft Shared\ClickToRun\OfficeC2RClient.exe" /changesetting Channel=Current
			}

			Write-Host "Updating Office, please wait 120 seconds to see further progress."
				& "C:\Program Files\Common Files\Microsoft Shared\ClickToRun\OfficeC2RClient.exe" /update user updatepromptuser=false forceappshutdown=true displaylevel=false
				Restart-Service -Name "ClickToRunSvc" -Force -ErrorAction SilentlyContinue
				Wait-UpdateStop OfficeClickToRun

				Write-Host "`n"

			Get-Office365Version
		}
	}
}

Function Update-PWSH {
	Write-Host "Updating PWSH"
	If (!(Get-Command choco -ErrorAction SilentlyContinue)) {Install-Choco}
	Choco upgrade pwsh -y
}

Function Update-Windows {
	Write-Host "Install Windows Updates"
		Set-ExecutionPolicy Bypass -Scope Process -Force
		Enable-SSL
		Invoke-WebRequest https://raw.githubusercontent.com/AmbitionsTechnologyGroup/ATG-PS-Functions/master/Scripts/Windows-Update/UpdateWindows.txt -UseBasicParsing | Invoke-Expression
	Write-Host "End of Install Windows Updates"
}

Function Update-WindowsApps {
	Write-Host "Updating Windows Apps"
		Start-Process ms-windows-store:
		Start-Sleep -Seconds 5
		(Get-WmiObject -Namespace "root\cimv2\mdm\dmmap" -Class "MDM_EnterpriseModernAppManagement_AppManagement01").UpdateScanMethod()
	Write-Host "Update Windows Apps initiated"
}

Function Update-WindowTitle ([String] $PassNumber) {
	Write-Host "Changing window title"
		$host.ui.RawUI.WindowTitle = "$SiteCode Provisioning | $env:computername | Pass $PassNumber | Please Wait"
}

If (Get-Module -Name ATGPS -ErrorAction SilentlyContinue){
	# List imported functions from ATGPS
	Write-Host `n====================================================
	Write-Host "The below functions are now loaded and ready to use:"
	Write-Host ====================================================

	Get-Command -Module ATGPS | Format-Wide -Column 3

	Write-Host ====================================================
	Write-Host "Type: 'Help <function name> -Detailed' for more info"
	Write-Host ====================================================
}
