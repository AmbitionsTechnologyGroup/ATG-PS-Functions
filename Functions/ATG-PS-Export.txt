Function Export-LDAPSCertificate {
	<#
	.SYNOPSIS
		If the server responds to requests on the LDAPS port 636, the function will attempt to isolate the Certificate in use and export it to C:\Ambitions\LDAPScerExport.cer
	#>
	If (Test-NetConnection -ComputerName localhost -Port 636 -InformationLevel Quiet) {
		$Cert = (Get-ChildItem -Path Cert:\LocalMachine -Recurse | Where-Object {$_.NotAfter -Gt (Get-Date) -and $_.Subject -like "*$env:computername.$env:userdnsdomain*" -and $_.NotAfter -eq ($_.NotBefore).AddYears(1)})
		$Cert | Select-Object Subject, NotBefore, NotAfter | Format-List
		$Path = "C:\Ambitions\LDAPScerExport.cer"
		Write-Host "Exporting current likely LDAPS Certificate to $Path"
		$Cert | Export-Certificate -Type cer -FilePath C:\Ambitions\LDAPScerExport.cer -Force | Out-Null
	} Else {
		Write-Warning "This computer does not appear to be serving LDAPS requests."
		Break
	}
}

Function Export-365AllDistributionGroups {
	param
	(
		[Parameter(Mandatory=$True)]
		[string]$SaveToFolder
	)

	If (-not $(Get-ConnectionInformation)) {Connect-O365Exchange;$DisconnectWhenDoneALL = $True}
	$AllDistributionGroups = Get-DistributionGroup
	$AllDistributionGroups.DisplayName | ForEach-Object {
		Write-Host $_
		Export-365DistributionGroup -DistributionGroup $_ -SavePath $(Join-Path -Path $SaveToFolder -ChildPath $($_ + ".csv"))
	}
	If ($DisconnectWhenDoneALL -eq $True) {
		Write-Host "Disconnecting from Exchange Online"
		Disconnect-O365Exchange
	}
}
Function Export-365DistributionGroup {
	param
	(
		[Parameter(Mandatory=$false)]
		[string]$DistributionGroup,
		[Parameter(Mandatory=$false)]
		[string]$SavePath
	)

	Function Save-File([string] $initialDirectory ) {

		[System.Reflection.Assembly]::LoadWithPartialName("System.windows.forms") | Out-Null
	
		$OpenFileDialog = New-Object System.Windows.Forms.SaveFileDialog
		$OpenFileDialog.initialDirectory = $initialDirectory
		$OpenFileDialog.filter = "All files (*.csv)| *.csv"
		$OpenFileDialog.ShowDialog() |  Out-Null
	
		return $OpenFileDialog.filename
	}
	
	Function Get-DistributionGroups {
		$DistributionGroups = Get-DistributionGroup
		If ($DistributionGroup) {
			If ($DistributionGroups.DisplayName -Match $DistributionGroup) {
				$Global:SelectedDG = Get-DistributionGroup $DistributionGroup
				Write-Host "You've selected $SelectedDG"
			} Else {
				Write-Host -ForegroundColor Yellow "$DistributionGroup is not a valid group."
			}
		}
	
		If (-not $SelectedDG) {
			$DistributionGroups | Select-Object @{N='Index'; E={$DistributionGroups.IndexOf($_)}}, DisplayName, PrimarySmtpAddress | Out-Host -Paging -ErrorAction SilentlyContinue
			$selection = Read-Host "Please enter the number of the Distribution Group you wish to select."
			$Global:SelectedDG = $DistributionGroups[$selection]
			Write-Host "You've selected $SelectedDG"
		}
	
	}
	
	Function Export-DistributionGroupMembers {
		$DGMembers = $SelectedDG | ForEach-Object {Get-DistributionGroupMember -Identity $_.Identity | Select-Object Name, PrimarySmtpAddress }
		Write-Host "$SelectedDG`nGetting members of list."
		function Show-Menu {
			param (
				[string]$Title = "$($DGMembers.count) members found in $SelectedDG"
			)
			Clear-Host
			Write-Host "================ $Title ================"
			Write-Host "What would you like to do with the list?"
			Write-Host
			Write-Host "1: View list of members."
			Write-Host "2: Copy list of members."
			Write-Host "3: Save list of members."
			Write-Host "Q: Press 'Q' to quit"
		}
	
		If (-not $SavePath) {
			do {
				Show-Menu
				$selection = Read-Host "Please make a selection"
				switch ($selection) {
					'1' {
	
						'================ You chose option #1: View List ================'
						Write-Host $SelectedDG
						$DGMembers | Format-Table | Out-Host | More
						Write-Host
						Pause
					} '2' {
	
						'================ You chose option #2: Copy list ================'
						$DGMembers | ConvertTo-Csv -Delimiter "`t" -NoTypeInformation | Set-Clipboard
						Write-Host "Results have been copied to the clipboard. You may paste in another program."
						Write-Host
						Pause
					} '3' {
	
						'================ You chose option #3: Save list ================'
	
						$SavePath = Save-File $env:USERPROFILE
						"sep=;" | Out-File -FilePath $SavePath -Force
						$DGMembers | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | Out-File -FilePath $SavePath -Append -Force
						Write-Host "The file has been saved to $SavePath"
						Write-Host
						Pause
					} 'q' {
						#exit
					}
				}
				#pause
			} until ($selection -eq 'q')
		} Else {
			"sep=;" | Out-File -FilePath $SavePath -Force
			$DGMembers | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | Out-File -FilePath $SavePath -Append -Force
			Write-Host "The file has been saved to $SavePath"
			Write-Host
		}
	}
	
	################################
	If (-not $(Get-ConnectionInformation)) {Connect-O365Exchange;$DisconnectWhenDone = $True}
	Get-DistributionGroups
	Export-DistributionGroupMembers
	Clear-Variable SelectedDG -Force -ErrorAction SilentlyContinue
	Clear-Variable DGMembers -Force -ErrorAction SilentlyContinue
	Clear-Variable DistributionGroup -Force -ErrorAction SilentlyContinue
	Clear-Variable DistributionGroups -Force -ErrorAction SilentlyContinue
	If ($DisconnectWhenDone -eq $True) {
		Write-Host "Disconnecting from Exchange Online"
		Disconnect-O365Exchange
	}
}

Function Export-UsersOneDrive {
	param
	(
		[Parameter(Mandatory=$false)]
		[string]$departinguser,

		[Parameter(Mandatory=$false)]
		[string]$destinationuser,
		
		[Parameter(Mandatory=$false)]
		[string]$globaladmin
	)
	
	Write-Host -ForegroundColor Yellow "Please note:`n- This process will require you to log in as the global admin in several windows.`n- This will take quite some time if there are extensive amounts of files.`n- This cannot copy files larger then 250mb."
	If (-not $departinguser) {$departinguser = Read-Host "Enter departing user's email"}
	If (-not $departinguser) {$destinationuser = Read-Host "Enter destination user's email"}
	If (-not $departinguser) {$globaladmin = Read-Host "Enter the username of your Global Admin account"}
	Connect-O365AzureAD -Quiet
	 
	$InitialDomain = Get-AzureADDomain | Where-Object {$_.IsInitial -eq $true}
	  
	$SharePointAdminURL = "https://$($InitialDomain.Name.Split(".")[0])-admin.sharepoint.com"
	  
	$departingUserUnderscore = $departinguser -replace "[^a-zA-Z]", "_"
	$destinationUserUnderscore = $destinationuser -replace "[^a-zA-Z]", "_"
	  
	$departingOneDriveSite = "https://$($InitialDomain.Name.Split(".")[0])-my.sharepoint.com/personal/$departingUserUnderscore"
	$destinationOneDriveSite = "https://$($InitialDomain.Name.Split(".")[0])-my.sharepoint.com/personal/$destinationUserUnderscore"
	Write-Host "`nConnecting to SharePoint Online" -ForegroundColor Blue
	Connect-O365SharePoint -Url $SharePointAdminURL -Quiet
	  
	Write-Host "`nAdding $globaladmin as site collection admin on both OneDrive site collections" -ForegroundColor Blue
	# Set current admin as a Site Collection Admin on both OneDrive Site Collections
	If ($(Get-SPODeletedSite -IncludeOnlyPersonalSite).Url -match $departingOneDriveSite) {
		Write-Host "$departingOneDriveSite has be deleted. Temporarily undeleting it for recovery."
		Restore-SPODeletedSite -Identity $departingOneDriveSite
		$WasDeleted = $True
	}
	Set-SPOUser -Site $departingOneDriveSite -LoginName $globaladmin -IsSiteCollectionAdmin $true
	Set-SPOUser -Site $destinationOneDriveSite -LoginName $globaladmin -IsSiteCollectionAdmin $true
	  
	Write-Host "`nConnecting to $departinguser's OneDrive via SharePoint Online PNP module" -ForegroundColor Blue
	  
	Connect-O365SharepointPNP -Url $departingOneDriveSite -Quiet
	  
	Write-Host "`nGetting display name of $departinguser" -ForegroundColor Blue
	# Get name of departing user to create folder name.https://pbwslaw-admin.sharepoint.com/
	$departingOwner = Get-PnPSiteCollectionAdmin | Where-Object {$_.loginname -match $departinguser}
	  
	# If there's an issue retrieving the departing user's display name, set this one.
	If ($departingOwner -contains $null) {
		$departingOwner = @{
			Title = "Departing User"
		}
	}
	  
	# Define relative folder locations for OneDrive source and destination
	$departingOneDrivePath = "/personal/$departingUserUnderscore/Documents"
	$destinationOneDrivePath = "/personal/$destinationUserUnderscore/Documents/$($departingOwner.Title)'s Files"
	$destinationOneDriveSiteRelativePath = "Documents/$($departingOwner.Title)'s Files"
	  
	Write-Host "`nGetting all items from $($departingOwner.Title)" -ForegroundColor Blue
	# Get all items from source OneDrive
	$items = Get-PnPListItem -List Documents -PageSize 1000
	  
	$largeItems = $items | Where-Object {[long]$_.fieldvalues.SMTotalFileStreamSize -ge 261095424 -and $_.FileSystemObjectType -contains "File"}
	If ($largeItems) {
		$largeexport = @()
		foreach ($item in $largeitems) {
			$largeexport += "$(Get-Date) - Size: $([math]::Round(($item.FieldValues.SMTotalFileStreamSize / 1MB),2)) MB Path: $($item.FieldValues.FileRef)"
			Write-Host "File too large to copy: $($item.FieldValues.FileRef)" -ForegroundColor DarkYellow
		}
		New-Item -Path $Env:SystemDrive\temp -ItemType Directory -Force
		$largeexport | Out-file $Env:SystemDrive\temp\largefiles.txt -Append
		Write-Host "A list of files too large to be copied from $($departingOwner.Title) have been exported to C:\temp\LargeFiles.txt" -ForegroundColor Yellow
	}
	  
	$rightSizeItems = $items | Where-Object {[long]$_.fieldvalues.SMTotalFileStreamSize -lt 261095424 -or $_.FileSystemObjectType -contains "Folder"}
	  
	Write-Host "`nConnecting to $destinationuser via SharePoint PNP PowerShell module" -ForegroundColor Blue
	Connect-O365SharepointPNP -Url $destinationOneDriveSite -Quiet
	  
	Write-Host "`nFilter by folders" -ForegroundColor Blue
	# Filter by Folders to create directory structure
	$folders = $rightSizeItems | Where-Object {$_.FileSystemObjectType -contains "Folder"}
	  
	Write-Host "`nCreating Directory Structure" -ForegroundColor Blue
	foreach ($folder in $folders) {
		$path = ('{0}{1}' -f $destinationOneDriveSiteRelativePath, $folder.fieldvalues.FileRef).Replace($departingOneDrivePath, '')
		Write-Host "Creating folder in $path" -ForegroundColor Green
		$newfolder = Resolve-PnPFolder -SiteRelativePath $path
	}
	   
	Write-Host "`nCopying Files" -ForegroundColor Blue
	$files = $rightSizeItems | Where-Object {$_.FileSystemObjectType -contains "File"}
	$fileerrors = ""
	foreach ($file in $files) {
		  
		$destpath = ("$destinationOneDrivePath$($file.fieldvalues.FileDirRef)").Replace($departingOneDrivePath, "")
		Write-Host "Copying $($file.fieldvalues.FileLeafRef) to $destpath" -ForegroundColor Green
		$newfile = Copy-PnPFile -SourceUrl $file.fieldvalues.FileRef -TargetUrl $destpath -OverwriteIfAlreadyExists -Force -ErrorVariable errors -ErrorAction SilentlyContinue
		$fileerrors += $errors
	}
	If ($fileerrors) {
		Write-Host -ForegroundColor Red "Errors were detected. A log is being saved at $Env:SystemDrive\temp\fileerrors.txt"
		New-Item -Path $Env:SystemDrive\temp -ItemType Directory -Force
		$fileerrors | Out-File $Env:SystemDrive\temp\fileerrors.txt
	}
	  
	# Remove Global Admin from Site Collection Admin role for both users
	Write-Host "`nRemoving $globaladmin from OneDrive site collections" -ForegroundColor Blue
	Set-SPOUser -Site $departingOneDriveSite -LoginName $globaladmin -IsSiteCollectionAdmin $false
	If ($globaladmin -ne $destinationuser) {
		Set-SPOUser -Site $destinationOneDriveSite -LoginName $globaladmin -IsSiteCollectionAdmin $false
	}
	
	If ($WasDeleted) {
		Write-Host "$departingOneDriveSite was previously deleted. Re-deleting it."
		Remove-SPOSite -Identity $departingOneDriveSite -Confirm:$false
	}
	Write-Host "`nDisconnecting from all services" -ForegroundColor Blue
	Disconnect-AzureAD
	Disconnect-SPOService
	Disconnect-PnPOnline -ErrorAction SilentlyContinue
	Write-Host "`nComplete!" -ForegroundColor Green
}